{"version":3,"sources":["webpack:///webpack/bootstrap ace6c486fa939cc82daf","webpack:///./web_modules/glfx/index.js","webpack:///./src/samples/skigame.ts","webpack:///./src/locate-print/index.ts","webpack:///./src/locate-print/shaders/colorshift.ts","webpack:///./src/locate-print/shaders/scanlines.ts","webpack:///./web_modules/gcc/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qCAAqC,gBAAgB,SAAS,qCAAqC,eAAe,2BAA2B,wBAAwB,eAAe,mBAAmB,EAAE,EAAE,gBAAgB,6BAA6B;AAC/Q,4BAA4B,yFAAyF,0CAA0C,MAAM,uBAAuB,cAAc,GAAG,YAAY,EAAE,cAAc;AACzO,yDAAyD,gBAAgB,iBAAiB,yCAAyC,8CAA8C,qEAAqE,uFAAuF,sBAAsB,YAAY,iEAAiE,GAAG;AACnb,GAAG;AACH;AACA,kHAAkH,WAAW,oCAAoC,kCAAkC,EAAE;AACrM,GAAG,eAAe,sBAAsB,iCAAiC,cAAc,yBAAyB,6BAA6B,yCAAyC,2BAA2B,EAAE,oDAAoD,gBAAgB,oCAAoC,6BAA6B;AACxV,gBAAgB,qFAAqF,sBAAsB,uBAAuB,kCAAkC,EAAE,cAAc,eAAe,wFAAwF,oCAAoC,uDAAuD,EAAE,WAAW,gBAAgB,qBAAqB,eAAe,kCAAkC,EAAE;AAC3e,mDAAmD,mBAAmB;AACtE,oBAAoB,yEAAyE;AAC7F,GAAG,gBAAgB,oFAAoF,UAAU,+EAA+E,uMAAuM;AACvY,qBAAqB,cAAc,cAAc,aAAa,cAAc,yBAAyB,qBAAqB,EAAE,gBAAgB,OAAO;AACnJ,kBAAkB,gBAAgB,YAAY,WAAW,OAAO,qCAAqC,uEAAuE,0BAA0B,gLAAgL,oBAAoB,gBAAgB,QAAQ;AACla,GAAG;AACH,sDAAsD,qBAAqB,sBAAsB,YAAY,4BAA4B;AACzI,yDAAyD,iDAAiD,wBAAwB,0DAA0D;AAC5L,GAAG;AACH,0FAA0F,yBAAyB,uBAAuB,sBAAsB,YAAY,uCAAuC,sBAAsB,iBAAiB,8CAA8C,KAAK,8CAA8C,oBAAoB;AAC/W,wCAAwC,iDAAiD,EAAE;AAC3F,GAAG,gBAAgB,cAAc,wBAAwB,SAAS,iEAAiE,WAAW;AAC9I,aAAa,0DAA0D,wBAAwB,SAAS,kDAAkD,8CAA8C,4BAA4B,+DAA+D,sBAAsB,sBAAsB,YAAY,uCAAuC,uCAAuC,uCAAuC,uCAAuC,oBAAoB;AAC3gB,uBAAuB,SAAS,EAAE,0BAA0B,EAAE;AAC9D,GAAG;AACH,oEAAoE,uBAAuB,uBAAuB,qBAAqB,sBAAsB,YAAY,wCAAwC,qBAAqB,gBAAgB,iBAAiB,OAAO,QAAQ,iBAAiB,OAAO,QAAQ,0DAA0D,4DAA4D,4BAA4B,qBAAqB,gBAAgB,0BAA0B;AACvgB,mBAAmB,OAAO,8BAA8B,+DAA+D,EAAE;AACzH,GAAG;AACH,gFAAgF,kBAAkB,yBAAyB,sBAAsB,YAAY,uCAAuC,2BAA2B,gCAAgC,gEAAgE,4BAA4B,iGAAiG,4CAA4C,mBAAmB,6DAA6D,KAAK,8CAA8C,oBAAoB;AAC/nB,mCAAmC,4CAA4C,EAAE;AACjF,GAAG;AACH,gEAAgE,qBAAqB,sBAAsB,oBAAoB,+DAA+D,YAAY,uCAAuC,uCAAuC,cAAc,cAAc,cAAc,oBAAoB;AACtV,2BAA2B,qBAAqB,EAAE;AAClD,GAAG;AACH,gEAAgE,qBAAqB,sBAAsB,YAAY,uCAAuC,gBAAgB,gBAAgB,gBAAgB,gFAAgF,4EAA4E,4EAA4E,oBAAoB;AAC1c,2BAA2B,qBAAqB,EAAE;AAClD,GAAG;AACH,mFAAmF,kCAAkC,uBAAuB,wBAAwB,sBAAsB,YAAY,gDAAgD,kDAAkD,iDAAiD;AACzV,qDAAqD,sBAAsB,yCAAyC,kCAAkC,EAAE,4BAA4B,sBAAsB,yBAAyB,qBAAqB,EAAE,8BAA8B,cAAc,EAAE,8BAA8B;AACtU,GAAG;AACH,sEAAsE,qBAAqB,sBAAsB,YAAY,uCAAuC,4CAA4C,2CAA2C,qCAAqC,sCAAsC,oBAAoB;AAC1V,8BAA8B,sBAAsB,EAAE;AACtD,GAAG;AACH,sEAAsE,mBAAmB,qBAAqB,sBAAsB,YAAY,uCAAuC,4CAA4C,yDAAyD,oBAAoB;AAChT,8BAA8B,uCAAuC,EAAE;AACvE,GAAG;AACH,oFAAoF,oBAAoB,sBAAsB,YAAY,uCAAuC,6BAA6B,0BAA0B,GAAG,qCAAqC,2BAA2B,oBAAoB,oBAAoB,oBAAoB,sBAAsB;AAC7X,mCAAmC,8CAA8C,qBAAqB,gBAAgB,gBAAgB,QAAQ,KAAK,8BAA8B,kDAAkD,YAAY,oBAAoB;AACnQ,8DAA8D,6BAA6B,GAAG,2DAA2D,kDAAkD,GAAG,4DAA4D,iEAAiE,qCAAqC,cAAc,cAAc,EAAE;AAC9Y,gBAAgB,OAAO,OAAO,iCAAiC,wEAAwE,+BAA+B,kCAAkC,WAAW,EAAE,kDAAkD,4BAA4B,eAAe,uCAAuC,4BAA4B,6BAA6B,4CAA4C,4BAA4B,eAAe,EAAE,4BAA4B,4BAA4B,6BAA6B,EAAE;AAClkB;AACA;AACA,wEAAwE,yBAAyB,6BAA6B,mBAAmB,iBAAiB,mBAAmB,qBAAqB,sBAAsB,qBAAqB,qBAAqB,gBAAgB,uDAAuD,yDAAyD,mGAAmG,kBAAkB,QAAQ,KAAK,kCAAkC,8BAA8B,qEAAqE,qBAAqB,qBAAqB,eAAe,yBAAyB,0CAA0C;AAC7wB,2DAA2D,4BAA4B,0HAA0H,EAAE,4BAA4B,2HAA2H,EAAE;AAC5W,GAAG;AACH,8EAA8E,mBAAmB,sBAAsB,qBAAqB,qBAAqB,gBAAgB,uDAAuD,kBAAkB,QAAQ,KAAK,kCAAkC,8BAA8B,sDAAsD,qBAAqB,qBAAqB,eAAe,yBAAyB,0CAA0C;AACzf,kCAAkC,6BAA6B,EAAE,+BAA+B,8BAA8B,EAAE;AAChI,GAAG;AACH,sEAAsE,oBAAoB,uBAAuB,qBAAqB,sBAAsB,qBAAqB,qBAAqB,gBAAgB,sCAAsC,uDAAuD,gBAAgB,QAAQ,KAAK,8BAA8B,2CAA2C,0EAA0E,qBAAqB,qBAAqB,eAAe,yBAAyB,0CAA0C;AAC/lB,8BAA8B,kEAAkE,EAAE;AAClG,GAAG;AACH,gFAAgF,oBAAoB,oBAAoB,oBAAoB,qBAAqB,sBAAsB,2BAA2B,gCAAgC,iCAAiC,uDAAuD,uCAAuC,YAAY,uCAAuC,uBAAuB,oCAAoC,oBAAoB,mGAAmG,mDAAmD,sCAAsC;AAC/qB,mCAAmC,mFAAmF,EAAE;AACxH,GAAG;AACH,wEAAwE,oBAAoB,oBAAoB,oBAAoB,qBAAqB,sBAAsB,gBAAgB,gCAAgC,iCAAiC,uDAAuD,uCAAuC,YAAY,uCAAuC,4CAA4C,6DAA6D;AAC1f,+BAA+B,mFAAmF,EAAE;AACpH,GAAG;AACH,wEAAwE,mBAAmB,sBAAsB,qBAAqB,qBAAqB,qBAAqB,uDAAuD,kBAAkB,QAAQ,KAAK,kCAAkC,8BAA8B,0DAA0D,+CAA+C,wBAAwB,gBAAgB,gBAAgB,sBAAsB,wBAAwB,kBAAkB,wCAAwC;AAC/kB,wEAAwE,mBAAmB,sBAAsB,qBAAqB,qBAAqB,qBAAqB,uDAAuD,kBAAkB,QAAQ,KAAK,kCAAkC,8BAA8B,yDAAyD,yBAAyB,gBAAgB,gBAAgB,sBAAsB,yBAAyB,kBAAkB,qEAAqE,8BAA8B;AAC5lB,+BAA+B,6BAA6B,EAAE,4BAA4B,8BAA8B,EAAE;AAC1H,GAAG;AACH,wFAAwF,oBAAoB,oBAAoB,qBAAqB,sBAAsB,YAAY,yCAAyC,mBAAmB,iBAAiB,OAAO,+EAA+E,qCAAqC,sCAAsC,sCAAsC,2CAA2C,iCAAiC,iCAAiC,iCAAiC,yBAAyB,yBAAyB,yBAAyB,YAAY,cAAc,sBAAsB,eAAe,KAAK,sBAAsB,eAAe,uBAAuB,sBAAsB,sBAAsB,uDAAuD;AACv4B,uCAAuC,+DAA+D,EAAE;AACxG,GAAG;AACH,4DAA4D,uBAAuB,qBAAqB,sBAAsB,YAAY,gCAAgC,gCAAgC,uCAAuC,mBAAmB,qBAAqB,0BAA0B,4BAA4B,iBAAiB,OAAO,QAAQ,iBAAiB,OAAO,QAAQ,sDAAsD,mBAAmB,cAAc,sBAAsB,qBAAqB,mBAAmB,qEAAqE,uEAAuE;AAChrB,yBAAyB,kEAAkE,EAAE;AAC7F,GAAG;AACH,2DAA2D,uBAAuB,oBAAoB,kBAAkB,6BAA6B,oBAAoB,8BAA8B,iBAAiB,uEAAuE,KAAK,6EAA6E,cAAc;AAC/X,gCAAgC,uFAAuF,EAAE;AACzH,GAAG;AACH,0DAA0D,6BAA6B,mDAAmD,iCAAiC,qBAAqB,iDAAiD,GAAG,yCAAyC;AAC7R,8CAA8C,sEAAsE,6BAA6B,mFAAmF,EAAE;AACtO,GAAG;AACH,6DAA6D;AAC7D;AACA,GAAG;AACH,iDAAiD,oBAAoB,oBAAoB,kBAAkB,6BAA6B,oBAAoB,uCAAuC,kCAAkC,mBAAmB,mBAAmB,qDAAqD,cAAc;AAC9U,2BAA2B,0EAA0E,EAAE;AACvG,GAAG,YAAY;AACf;AACA,0DAA0D,sDAAsD,gCAAgC,gEAAgE,gEAAgE,kEAAkE;AAClV,oFAAoF,qCAAqC,gFAAgF,uBAAuB,gCAAgC,+DAA+D,+DAA+D,kEAAkE,kEAAkE;AAClgB,iHAAiH,uGAAuG,0CAA0C,YAAY,kCAAkC,GAAG,8CAA8C,YAAY,2CAA2C,GAAG,oBAAoB,oBAAoB,sBAAsB;AACzd,aAAa,kBAAkB,sBAAsB,iCAAiC,uEAAuE,8BAA8B,gDAAgD,uBAAuB,iBAAiB,wBAAwB,gCAAgC,8BAA8B,sDAAsD;AAC/Z,KAAK,eAAe,EAAE;AACtB;AACA,uCAAuC,+DAA+D,8DAA8D;AACpK,KAAK,eAAe,sBAAsB,oFAAoF,WAAW,MAAM,4EAA4E,YAAY,EAAE;AACzO;AACA,uDAAuD;AACvD;AACA,GAAG,IAAI,OAAO;AACd,6CAA6C,MAAM,yCAAyC,yBAAyB,GAAG,YAAY,WAAW,qDAAqD,QAAQ,oFAAoF,kBAAkB,eAAe,iBAAiB,kBAAkB,mBAAmB,wBAAwB;AAC/Y,+BAA+B,wBAAwB,wBAAwB,uBAAuB,sBAAsB,uBAAuB,qBAAqB,qBAAqB,oBAAoB,oBAAoB,mBAAmB,mBAAmB,mBAAmB,gBAAgB,kBAAkB,iBAAiB,iBAAiB,cAAc,mBAAmB,mBAAmB,gBAAgB;AACta,IAAI,yBAAyB;AAC7B;AACA,gCAAgC,sBAAsB,oBAAoB;AAC1E,2EAA2E;AAC3E,KAAK,mBAAmB,sDAAsD,kCAAkC,YAAY,YAAY,4BAA4B,MAAM,qDAAqD,uDAAuD,6BAA6B,mHAAmH,EAAE,gCAAgC,yBAAyB,sBAAsB,YAAY,mBAAmB,0CAA0C;AAChkB,qCAAqC,sBAAsB,YAAY,0CAA0C,EAAE,oCAAoC,+BAA+B,uBAAuB;AAC7M,mCAAmC;AACnC,wDAAwD;AACxD,yBAAyB;AACzB,2DAA2D;AAC3D,2DAA2D,OAAO,8CAA8C,OAAO,8CAA8C,OAAO,wDAAwD,OAAO,yDAAyD,OAAO;AAC3S,aAAa,oFAAoF;AACjG;AACA,SAAS;AACT,QAAQ,sCAAsC,4BAA4B,kGAAkG,eAAe;AAC3L,2CAA2C,0CAA0C,0CAA0C,0CAA0C,0CAA0C,+DAA+D,8CAA8C;AAChU,gDAAgD,4MAA4M,uJAAuJ;AACnZ,mCAAmC,8CAA8C,mEAAmE,gDAAgD,qEAAqE;AACzQ,QAAQ,mCAAmC,4CAA4C,0BAA0B;AACjH,GAAG,GAAG;AACN,2CAA2C,WAAW,GAAG,oBAAoB,iCAAiC;AAC9G,2CAA2C,0BAA0B;AACrE,IAAI;AACJ;AACA,kBAAkB,6BAA6B,gBAAgB,iBAAiB,iBAAiB,eAAe,sCAAsC,+DAA+D,+DAA+D,kEAAkE;AACtV,2CAA2C;AAC3C,KAAK,gBAAgB,qDAAqD,mBAAmB,qBAAqB,wBAAwB,sCAAsC,WAAW,+BAA+B,8CAA8C,qBAAqB,YAAY;AACzS,2CAA2C,yCAAyC;AACpF,iBAAiB;AACjB,MAAM,iDAAiD,gBAAgB,iBAAiB,sBAAsB,6BAA6B,sCAAsC,wFAAwF,oCAAoC,0BAA0B,kBAAkB,iCAAiC,wCAAwC,wCAAwC;AAC1c;AACA,kBAAkB;AAClB,MAAM,mDAAmD,6BAA6B,sBAAsB,aAAa,cAAc,cAAc,aAAa,2QAA2Q;AAC7a,6DAA6D;AAC7D,uBAAuB,sFAAsF,+GAA+G,2CAA2C,KAAK;AAC5Q,MAAM,cAAc,6CAA6C,YAAY,sBAAsB,6BAA6B,sCAAsC,mEAAmE;AACzO,wCAAwC,YAAY,iCAAiC,0HAA0H,yEAAyE,gBAAgB,OAAO,sBAAsB,yBAAyB,yBAAyB;AACvX,YAAY,UAAU,gBAAgB,aAAa,aAAa,sBAAsB,gBAAgB,cAAc,wBAAwB,iBAAiB,cAAc;AAC3K,oBAAoB;AACpB,MAAM;AACN,GAAG,6CAA6C,qEAAqE;AACrH;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;AC7JA,WAAW;AACX,yEAAyE;;AAEzE,gCAA4C;AAC5C,iCAA2B;AAE3B,IAAI,SAAoB,CAAC;AACzB,IAAI,KAAa;AACjB,IAAI,KAAa,CAAC;AAClB,IAAI,EAAU,CAAC;AACf,IAAI,SAAiB,CAAC;AACtB,IAAI,OAAgB,CAAC;AACrB,IAAI,UAAmB,CAAC;AAExB,IAAI,eAAe,GAAG,KAAK,CAAC;AAE5B,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACvB,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;AAEzB,MAAM,CAAC,MAAM,GAAG;IACf,yBAAyB;IACzB,EAAE,CAAC,IAAI,EAAE,CAAC;IACV,8BAA8B;IAC9B,EAAE,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IAC5B,2CAA2C;IAC3C,qBAAqB;IACrB,EAAE,CAAC,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAC3B,8CAA8C;IAC9C,8CAA8C;IAC9C,oDAAoD;IACpD,EAAE,CAAC,gBAAgB,CAAC,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;IACxC,gDAAgD;IAChD,mBAAmB;IACnB,EAAE,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IACnB,SAAS,GAAG,KAAK,CAAC,GAAG,EAAE,cAAM,YAAK,EAAL,CAAK,CAAC,CAAC;IACpC,MAAM,CAAC,SAAS,GAAG,UAAC,CAAgB;QACnC,IAAI,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC;QACnB,SAAS,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;QACrB,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;YAC1B,CAAC,CAAC,cAAc,EAAE,CAAC;QACpB,CAAC;IACF,CAAC,CAAC;IACF,MAAM,CAAC,OAAO,GAAG,UAAC,CAAgB;QACjC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;IAC9B,CAAC,CAAC;IACF,UAAU,EAAE,CAAC;IACb,qBAAqB,CAAC,WAAW,CAAC,CAAC;AACpC,CAAC;AAED;IACC,qBAAqB,CAAC,WAAW,CAAC,CAAC;IACnC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QACb,WAAW,EAAE,CAAC;IACf,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;QACvB,cAAc,EAAE,CAAC;IAClB,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,UAAU,EAAE,CAAC;IACd,CAAC;IACD,EAAE,CAAC,MAAM,EAAE,CAAC;IACZ,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;QACrB,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;IAC1B,CAAC;IACD,KAAK,EAAE,CAAC;AACT,CAAC;AAED;IACC,KAAK,GAAG,CAAC,CAAC;IACV,OAAO,GAAG,IAAI,CAAC;IACf,oBAAoB;IACpB,EAAE,CAAC,GAAG,EAAE,CAAC;AACV,CAAC;AAED;IACC,KAAK,GAAG,CAAC,CAAC;IACV,OAAO,GAAG,UAAU,GAAG,KAAK,CAAC;IAC7B,KAAK,GAAG,CAAC,CAAC;IACV,SAAS,GAAG,EAAE,CAAC;IACf,EAAE,GAAG,EAAE,CAAC;IACR,EAAE,CAAC,GAAG,EAAE,CAAC;AACV,CAAC;AAED;IACC,KAAK,GAAG,CAAC,CAAC;IACV,UAAU,GAAG,IAAI,CAAC;AACnB,CAAC;AAED;IACC,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9B,SAAS,EAAE,CAAC;IACb,CAAC;IACD,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC,CAAC,CAAC;QAChB,IAAI,EAAE,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;QACnD,0BAA0B;QAC1B,uCAAuC;QACvC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACf,8BAA8B;QAC9B,EAAE,CAAC,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QAC7B,iBAAiB;QACjB,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IACd,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,IAAI,CAAC,GAAG,KAAK,GAAG,EAAE,CAAC;QACnB,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACZ,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACjB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACb,EAAE,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACjC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YACrB,EAAE,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACjC,CAAC;IACF,CAAC;IACD,EAAE,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACnB,SAAS,EAAE,CAAC;IACb,CAAC;AACF,CAAC;AAED;IACC,SAAS,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC;IACrC,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;IACvC,EAAE,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC;IACR,CAAC;IACD,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACjB,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACZ,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACd,EAAE,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QAC7B,EAAE,EAAE,CAAC;IACN,CAAC;IACD,EAAE,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;QAC9B,EAAE,EAAE,CAAC;IACN,CAAC;IACD,sBAAsB;IACtB,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACjB,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACf,6DAA6D;IAC7D,IAAI,EAAE,GAAW,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IAClC,EAAE,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;QAChB,EAAE,CAAC,MAAM,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QACrB,EAAE,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;QACjC,KAAK,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC;QAC1B,SAAS,IAAI,EAAE,CAAC;IACjB,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;QACrC,aAAa,EAAE,CAAC;QAChB,MAAM,CAAC;IACR,CAAC;IACD,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACjB,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACd,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACZ,EAAE,CAAC,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;QAChC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QAChC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QACnC,IAAI,GAAG,GAAG,GAAG,CAAC;QACd,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAChC,GAAG,IAAI,GAAG,CAAC;QACZ,CAAC;QACD,GAAG,IAAI,GAAG,CAAC;QACX,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACjB,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACf,CAAC;IACD,SAAS,EAAE,CAAC;AACb,CAAC;AAED;IACC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACZ,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAChB,EAAE,CAAC,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;AAC5B,CAAC;AAED;IACC,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;QACjB,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACf,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;QACjB,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QACtB,SAAS,EAAE,CAAC;IACb,CAAC;IACD,EAAE,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC;QACjB,UAAU,EAAE,CAAC;IACd,CAAC;IACD,EAAE,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACnB,SAAS,EAAE,CAAC;IACb,CAAC;AACF,CAAC;AAED,eAAe,CAAS,EAAE,IAAc;IACvC,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACtB,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;;;;;;;;;AC3LD,wDAAwD;AACxD,6CAA6C;;AAE7C,gCAA2B;AAC3B,0CAA8C;AAC9C,yCAA4C;AAE/B,kBAAU,GAAG,CAAC,CAAC;AACf,wBAAgB,GAAG,CAAC,CAAC;AACrB,wBAAgB,GAAG,CAAC,CAAC;AAKvB,eAAO,GAAG,CAAC,CAAC;AACZ,eAAO,GAAG,CAAC,CAAC;AACvB,IAAI,OAAiC,CAAC;AACtC,IAAI,aAAuB,CAAC;AAC5B,IAAI,QAAgB,CAAC;AACrB,IAAI,OAAY,CAAC;AACjB,IAAI,KAAK,GAAG,CAAC,CAAC;AACd,IAAI,KAAiB,CAAC;AACtB,IAAI,MAAkB,CAAC;AACvB,IAAI,gBAA4B,CAAC;AACjC,IAAI,YAAoB,CAAC;AACzB,IAAI,sBAA8B,CAAC;AACnC,IAAI,gBAAwB,CAAC;AAC7B,IAAI,gBAAwB,CAAC;AAC7B,IAAI,SAAiB,CAAC;AACtB,IAAI,UAAkB,CAAC;AAEvB;IACC,gBAAQ,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC;IACvB,gBAAQ,CAAC,UAAU,GAAG,EAAE,CAAC,IAAI,CAAC,oBAAU,CAAC,CAAC;IAC1C,gBAAQ,CAAC,SAAS,GAAG,EAAE,CAAC,IAAI,CAAC,mBAAS,CAAC,CAAC;IACxC,cAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;IAC1C,cAAM,CAAC,KAAK,GAAG,GAAG,CAAC;IACnB,cAAM,CAAC,MAAM,GAAG,GAAG,CAAC;IACpB,OAAO,GAAG,cAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IAClC,OAAO,GAAG,gBAAQ,CAAC,OAAO,CAAC,cAAM,CAAC,CAAC;IACnC,aAAa;QACZ,CAAC,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IACzE,QAAQ,GAAG,OAAO,CAAC,gBAAe;IAClC,YAAY,GAAG,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC;IACxC,sBAAsB,GAAG,CAAC,CAAC;IAC3B,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAChB,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,gBAAQ,CAAC,CAAC;AACrC,CAAC;AAhBD,oBAgBC;AAED,uBAA8B,KAAa,EAAE,MAAc;IAC1D,cAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,cAAM,CAAC,MAAM,GAAG,MAAM,CAAC;AACxB,CAAC;AAHD,sCAGC;AAED,wBAA+B,KAAa;IAC3C,gBAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;AACxB,CAAC;AAFD,wCAEC;AAED,0BAAiC,cAA+B;IAA/B,sDAA+B;IAC/D,aAAa,GAAG,cAAc,CAAC;IAC/B,YAAY,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;IACzC,sBAAsB,GAAG,CAAC,CAAC;AAC5B,CAAC;AAJD,4CAIC;AAED,qBAA4B,SAAiB;IAC5C,QAAQ,GAAG,SAAS,CAAC;AACtB,CAAC;AAFD,kCAEC;AAED;IACC,WAAW,EAAE,CAAC;IACd,OAAO,CAAC,cAAc,CAAC,cAAM,CAAC,CAAC;IAC/B,gBAAQ,CAAC,IAAI,CAAC,OAAO,CAAC;QACrB,UAAU,EAAE;QACZ,SAAS,CAAC,KAAK,GAAG,cAAM,CAAC,MAAM,GAAG,QAAQ,CAAC;QAC3C,UAAU,CAAC,cAAM,CAAC,KAAK,GAAG,CAAC,EAAE,cAAM,CAAC,MAAM,GAAG,CAAC,EAC9C,cAAM,CAAC,KAAK,GAAG,IAAI,EAAE,IAAI,CAAC;QAC1B,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;QACpB,MAAM,EAAE,CAAC;IACV,KAAK,EAAE,CAAC;AACT,CAAC;AAXD,wBAWC;AAED,iBAAwB,KAAa,EAAE,MAAc;IACpD,oBAAY,GAAG,KAAK,CAAC;IACrB,qBAAa,GAAG,MAAM,CAAC;IACvB,KAAK,GAAG,KAAK,CAAC,KAAK,EAAE,cAAM,YAAK,CAAC,MAAM,EAAE,cAAM,WAAI,EAAJ,CAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;IACtD,MAAM,GAAG,KAAK,CAAC,KAAK,EAAE,cAAM,YAAK,CAAC,MAAM,EAAE,cAAM,QAAC,EAAD,CAAC,CAAC,EAAtB,CAAsB,CAAC,CAAC;IACpD,gBAAgB,GAAG,KAAK,CAAC,KAAK,EAAE,cAAM,YAAK,CAAC,MAAM,EAAE,cAAM,QAAC,EAAD,CAAC,CAAC,EAAtB,CAAsB,CAAC,CAAC;IAC9D,GAAG,EAAE,CAAC;AACP,CAAC;AAPD,0BAOC;AAED,gBAAuB,CAAS,EAAE,CAAS;IAC1C,eAAO,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,oBAAY,GAAG,CAAC,CAAC,CAAC;IACpD,eAAO,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,qBAAa,GAAG,CAAC,CAAC,CAAC;AACtD,CAAC;AAHD,wBAGC;AAED,eAAsB,IAAY,EAAE,UAA+B;IAA/B,0CAAqB,kBAAU;IAClE,YAAY,EAAE,CAAC;IACf,OAAO,CAAC,IAAI,EAAE,UAAC,CAAS;QACvB,EAAE,CAAC,CAAC,eAAO,IAAI,qBAAa,CAAC,CAAC,CAAC;YAC9B,MAAM,CAAC,KAAK,CAAC;QACd,CAAC;QACD,KAAK,CAAC,eAAO,CAAC,CAAC,eAAO,CAAC,GAAG,CAAC,CAAC;QAC5B,MAAM,CAAC,eAAO,CAAC,CAAC,eAAO,CAAC,GAAG,YAAY,CAAC;QACxC,gBAAgB,CAAC,eAAO,CAAC,CAAC,eAAO,CAAC;YACjC,sBAAsB,CAAC;QACxB,eAAO,EAAE,CAAC;QACV,EAAE,CAAC,CAAC,eAAO,IAAI,oBAAY,CAAC,CAAC,CAAC;YAC7B,eAAO,GAAG,CAAC,CAAC;YACZ,eAAO,EAAE,CAAC;YACV,EAAE,CAAC,CAAC,CAAC,UAAU,KAAK,kBAAU;gBAC7B,eAAO,IAAI,qBAAa,CAAC,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACf,CAAC;QACF,CAAC;IACF,CAAC,CAAC,CAAC;IACH,EAAE,CAAC,CAAC,UAAU,KAAK,wBAAgB;QAClC,eAAO,IAAI,qBAAa,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/B,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACf,CAAC;IACD,MAAM,CAAC,IAAI,CAAC;AACb,CAAC;AAzBD,sBAyBC;AAED,eAAsB,UAAkB,EAAE,UAAsB;IAAtB,2CAAsB;IAC/D,YAAY,GAAG,UAAU,CAAC;IAC1B,sBAAsB,GAAG,UAAU,CAAC;AACrC,CAAC;AAHD,sBAGC;AAED;IACC,KAAK,CAAC,qBAAa,EAAE,UAAC,CAAC;QACtB,KAAK,CAAC,oBAAY,EAAE,UAAC,CAAC;YACrB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QACpB,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;IACH,eAAO,GAAG,eAAO,GAAG,CAAC,CAAC;AACvB,CAAC;AAPD,kBAOC;AAED,gBAAuB,OAAe,EAAE,OAAmB;IAAnB,qCAAmB;IAC1D,IAAI,CAAC,GAAG,oBAAY,CAAC;IACrB,IAAI,CAAC,GAAG,qBAAa,CAAC;IACtB,IAAI,MAAM,GAAG,KAAK,CAAC,CAAC,EAAE,cAAM,YAAK,CAAC,CAAC,EAAE,cAAM,WAAI,EAAJ,CAAI,CAAC,EAApB,CAAoB,CAAC,CAAC;IAClD,IAAI,OAAO,GAAG,KAAK,CAAC,CAAC,EAAE,cAAM,YAAK,CAAC,CAAC,EAAE,cAAM,QAAC,EAAD,CAAC,CAAC,EAAjB,CAAiB,CAAC,CAAC;IAChD,IAAI,iBAAiB,GAAG,KAAK,CAAC,CAAC,EAAE,cAAM,YAAK,CAAC,CAAC,EAAE,cAAM,QAAC,EAAD,CAAC,CAAC,EAAjB,CAAiB,CAAC,CAAC;IAC1D,KAAK,CAAC,qBAAa,EAAE,UAAC,CAAC;QACtB,IAAI,EAAE,GAAG,CAAC,GAAG,OAAO,CAAC;QACrB,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,qBAAa,CAAC,CAAC,CAAC;YACnC,KAAK,CAAC,oBAAY,EAAE,UAAC,CAAC;gBACrB,IAAI,EAAE,GAAG,CAAC,GAAG,OAAO,CAAC;gBACrB,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,oBAAY,CAAC,CAAC,CAAC;oBAClC,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC7B,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC/B,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpD,CAAC;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;IACF,CAAC,CAAC,CAAC;IACH,KAAK,GAAG,MAAM,CAAC;IACf,MAAM,GAAG,OAAO,CAAC;IACjB,gBAAgB,GAAG,iBAAiB,CAAC;IACrC,eAAO,GAAG,KAAK,CAAC,eAAO,GAAG,OAAO,EAChC,CAAC,EAAE,oBAAY,GAAG,CAAC,CAAC,CAAC;IACtB,eAAO,GAAG,KAAK,CAAC,eAAO,GAAG,OAAO,EAChC,CAAC,EAAE,qBAAa,GAAG,CAAC,CAAC,CAAC;AACxB,CAAC;AA1BD,wBA0BC;AAED,gBAAuB,CAAS,EAAE,CAAS;IAC1C,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,oBAAY,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,qBAAa,CAAC,CAAC,CAAC;QAC/D,MAAM,CAAC,IAAI,CAAC;IACb,CAAC;IACD,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC;AALD,wBAKC;AAED;IACC,gBAAgB,GAAG,cAAM,CAAC,KAAK,GAAG,IAAI,CAAC;IACvC,gBAAgB,GAAG,cAAM,CAAC,MAAM,GAAG,IAAI,CAAC;IACxC,SAAS;QACR,CAAC,cAAM,CAAC,KAAK,GAAG,gBAAgB,GAAG,CAAC,CAAC,GAAG,oBAAY,CAAC;IACtD,UAAU;QACT,CAAC,cAAM,CAAC,MAAM,GAAG,gBAAgB,GAAG,CAAC,CAAC,GAAG,qBAAa,CAAC;IACxD,OAAO,CAAC,IAAI;QACX,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,GAAG,CAAC,GAAG,KAAK,GAAG,QAAQ,CAAC;IACjD,OAAO,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC7B,OAAO,CAAC,YAAY,GAAG,QAAQ,CAAC;AACjC,CAAC;AAED;IACC,YAAY,EAAE,CAAC;IACf,OAAO,CAAC,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;IACrC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,EAAE,gBAAgB,GAAG,GAAG,EACxD,cAAM,CAAC,KAAK,GAAG,gBAAgB,GAAG,CAAC,EACnC,cAAM,CAAC,MAAM,GAAG,gBAAgB,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;IAC7C,KAAK,CAAC,qBAAa,EAAE,UAAC,CAAC;QACtB,KAAK,CAAC,oBAAY,EAAE,UAAC,CAAC;YACrB,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACJ,CAAC;AAED,kBAAkB,CAAS,EAAE,CAAS;IACrC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACpB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACR,MAAM,CAAC;IACR,CAAC;IACD,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,SAAS,GAAG,gBAAgB,CAAC;IAClD,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,UAAU,GAAG,gBAAgB,CAAC;IACnD,IAAI,IAAI,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClC,EAAE,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;QACd,OAAO,CAAC,SAAS,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QACxC,OAAO,CAAC,QAAQ,CACd,EAAE,GAAG,SAAS,GAAG,CAAC,EAAE,EAAE,GAAG,UAAU,GAAG,CAAC,EACxC,SAAS,EAAE,UAAU,CAAC,CAAC;IACzB,CAAC;IACD,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QACf,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACvB,OAAO,CAAC,SAAS,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC;QACvC,OAAO,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC7B,CAAC;AACF,CAAC;AAED,eAAe,CAAS,EAAE,GAAW,EAAE,GAAW;IACjD,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QACb,MAAM,CAAC,GAAG,CAAC;IACZ,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QACpB,MAAM,CAAC,GAAG,CAAC;IACZ,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,MAAM,CAAC,CAAC,CAAC;IACV,CAAC;AACF,CAAC;AAED,eAAe,CAAS,EAAE,IAAc;IACvC,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACtB,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;AAED,iBAAiB,KAAqB,EAAE,IAAc;IACrD,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACvC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7B,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;;;;;;;;;;AClPD,gCAA2B;AAE3B;IACC,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,EAAE;;;;;;;;;;;;EAYhC,CAAC,CAAC;IACH,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE;QAClC,QAAQ,EAAE,IAAI,CAAC,KAAK;KACpB,CAAC,CAAC;IACH,MAAM,CAAC,IAAI,CAAC;AACb,CAAC;AAlBD,6BAkBC;;;;;;;;;;ACpBD,gCAA2B;AAE3B,mBAAkC,MAAM;IACvC,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,EAAE;;;;;;;;;;;;;EAahC,CAAC,CAAC;IACH,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE;QAClC,QAAQ,EAAE,IAAI,CAAC,MAAM;QACrB,MAAM,EAAE,MAAM;KACd,CAAC,CAAC;IACH,MAAM,CAAC,IAAI,CAAC;AACb,CAAC;AApBD,4BAoBC;;;;;;;ACtBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B,EAAE;AACrF,sDAAsD,cAAc,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,SAAS;AACrC;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA,0DAA0D,OAAO;AACjE;AACA;;AAEA;AACA,aAAa;AACb;AACA,0BAA0B;AAC1B,kBAAkB;AAClB,mBAAmB;AACnB,iBAAiB;AACjB,uBAAuB;AACvB;AACA,aAAa;AACb,cAAc;AACd,qBAAqB;AACrB,kBAAkB;AAClB,gBAAgB;AAChB,sBAAsB;AACtB,mBAAmB;AACnB,oBAAoB;AACpB,2BAA2B;AAC3B;AACA,uBAAuB;AACvB,mBAAmB;AACnB,+EAA+E;;AAE/E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uBAAuB;;AAEvB;AACA,oBAAoB;AACpB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA,wBAAwB;AACxB,uCAAuC;AACvC,qBAAqB;AACrB;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,gFAAgF,oBAAoB;AACpG;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;;AAE3B,sBAAsB,OAAO;;AAE7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,sBAAsB;AACtB;AACA;AACA;AACA;AACA,gBAAgB;AAChB,MAAM;AACN;AACA,gBAAgB;AAChB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf,uBAAuB;AACvB,+BAA+B;AAC/B,sBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,mCAAmC;AACnC;AACA,sBAAsB;AACtB;;;AAGA;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB,mBAAmB;AACnB;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,sBAAsB;AACtB,sBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,uBAAuB;AACvB,2CAA2C;AAC3C,sBAAsB;AACtB,sBAAsB;AACtB,wBAAwB;AACxB,sBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd,sBAAsB;AACtB,eAAe;AACf,8BAA8B;AAC9B;AACA;AACA,qBAAqB;AACrB,oBAAoB;;AAEpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,WAAW;AAC/B;;AAEA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;;AAEA;AACA,wBAAwB,eAAe;AACvC;AACA,yBAAyB;;AAEzB;AACA,wBAAwB;;AAExB;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B,8BAA8B;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC,6BAA6B;AAC7B;AACA,oCAAoC;AACpC,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,QAAQ;;AAER;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,2CAA2C,SAAS,aAAa;AACjE,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,qBAAqB;;AAErB;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA,gCAAgC;AAChC,2BAA2B;AAC3B;AACA,2CAA2C;AAC3C,sBAAsB;;AAEtB;AACA,2BAA2B;AAC3B;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,mBAAmB;AACnB,iBAAiB;;AAEjB,2BAA2B;AAC3B,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB,aAAa;;AAE7B;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,aAAa;AACjC;;AAEA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,aAAa;;AAE7B;AACA;AACA,uBAAuB;;AAEvB;AACA,sBAAsB,aAAa;;AAEnC;AACA,+BAA+B;AAC/B;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC,cAAc;;AAEhD;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,SAAS,8BAA8B;AACrE;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,SAAS;;AAEzB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA,qBAAqB;AACrB,eAAe;;AAEf;;AAEA;AACA;AACA,yBAAyB;;AAEzB,wCAAwC;;AAExC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB;;AAEzB,mCAAmC;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,YAAY,EAAE;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,CAAC;AACD,C","file":"skigame.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/samples\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ace6c486fa939cc82daf","/*\n * glfx.js\n * http://evanw.github.com/glfx.js/\n *\n * Copyright 2011 Evan Wallace\n * Released under the MIT license\n */\nvar fx = function () {\n  function q(a, d, c) { return Math.max(a, Math.min(d, c)) } function w(b) { return { _: b, loadContentsOf: function (b) { a = this._.gl; this._.loadContentsOf(b) }, destroy: function () { a = this._.gl; this._.destroy() } } } function A(a) { return w(r.fromElement(a)) } function B(b, d) {\n    var c = a.UNSIGNED_BYTE; if (a.getExtension(\"OES_texture_float\") && a.getExtension(\"OES_texture_float_linear\")) { var e = new r(100, 100, a.RGBA, a.FLOAT); try { e.drawTo(function () { c = a.FLOAT }) } catch (g) { } e.destroy() } this._.texture && this._.texture.destroy();\n    this._.spareTexture && this._.spareTexture.destroy(); this.width = b; this.height = d; this._.texture = new r(b, d, a.RGBA, c); this._.spareTexture = new r(b, d, a.RGBA, c); this._.extraTexture = this._.extraTexture || new r(0, 0, a.RGBA, c); this._.flippedShader = this._.flippedShader || new h(null, \"uniform sampler2D texture;varying vec2 texCoord;void main(){gl_FragColor=texture2D(texture,vec2(texCoord.x,1.0-texCoord.y));}\"); this._.isInitialized = !0\n  } function C(a, d, c) {\n    this._.isInitialized &&\n      a._.width == this.width && a._.height == this.height || B.call(this, d ? d : a._.width, c ? c : a._.height); a._.use(); this._.texture.drawTo(function () { h.getDefaultShader().drawRect() }); return this\n  } function D() { this._.texture.use(); this._.flippedShader.drawRect(); return this } function f(a, d, c, e) { (c || this._.texture).use(); this._.spareTexture.drawTo(function () { a.uniforms(d).drawRect() }); this._.spareTexture.swapWith(e || this._.texture) } function E(a) { a.parentNode.insertBefore(this, a); a.parentNode.removeChild(a); return this }\n  function F() { var b = new r(this._.texture.width, this._.texture.height, a.RGBA, a.UNSIGNED_BYTE); this._.texture.use(); b.drawTo(function () { h.getDefaultShader().drawRect() }); return w(b) } function G() { var b = this._.texture.width, d = this._.texture.height, c = new Uint8Array(4 * b * d); this._.texture.drawTo(function () { a.readPixels(0, 0, b, d, a.RGBA, a.UNSIGNED_BYTE, c) }); return c } function k(b) { return function () { a = this._.gl; return b.apply(this, arguments) } } function x(a, d, c, e, g, l, n, p) {\n    var m = c - g, h = e - l, f = n - g, k = p - l; g = a - c + g - n; l =\n      d - e + l - p; var q = m * k - f * h, f = (g * k - f * l) / q, m = (m * l - g * h) / q; return [c - a + f * c, e - d + f * e, f, n - a + m * n, p - d + m * p, m, a, d, 1]\n  } function y(a) { var d = a[0], c = a[1], e = a[2], g = a[3], l = a[4], n = a[5], p = a[6], m = a[7]; a = a[8]; var f = d * l * a - d * n * m - c * g * a + c * n * p + e * g * m - e * l * p; return [(l * a - n * m) / f, (e * m - c * a) / f, (c * n - e * l) / f, (n * p - g * a) / f, (d * a - e * p) / f, (e * g - d * n) / f, (g * m - l * p) / f, (c * p - d * m) / f, (d * l - c * g) / f] } function z(a) {\n    var d = a.length; this.xa = []; this.ya = []; this.u = []; this.y2 = []; a.sort(function (a, b) { return a[0] - b[0] }); for (var c = 0; c < d; c++)this.xa.push(a[c][0]), this.ya.push(a[c][1]);\n    this.u[0] = 0; this.y2[0] = 0; for (c = 1; c < d - 1; ++c) { a = this.xa[c + 1] - this.xa[c - 1]; var e = (this.xa[c] - this.xa[c - 1]) / a, g = e * this.y2[c - 1] + 2; this.y2[c] = (e - 1) / g; this.u[c] = (6 * ((this.ya[c + 1] - this.ya[c]) / (this.xa[c + 1] - this.xa[c]) - (this.ya[c] - this.ya[c - 1]) / (this.xa[c] - this.xa[c - 1])) / a - e * this.u[c - 1]) / g } this.y2[d - 1] = 0; for (c = d - 2; 0 <= c; --c)this.y2[c] = this.y2[c] * this.y2[c + 1] + this.u[c]\n  } function u(a, d) {\n    return new h(null, a + \"uniform sampler2D texture;uniform vec2 texSize;varying vec2 texCoord;void main(){vec2 coord=texCoord*texSize;\" +\n      d + \"gl_FragColor=texture2D(texture,coord/texSize);vec2 clampedCoord=clamp(coord,vec2(0.0),texSize);if(coord!=clampedCoord){gl_FragColor.a*=max(0.0,1.0-length(coord-clampedCoord));}}\")\n  } function H(b, d) {\n    a.brightnessContrast = a.brightnessContrast || new h(null, \"uniform sampler2D texture;uniform float brightness;uniform float contrast;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);color.rgb+=brightness;if(contrast>0.0){color.rgb=(color.rgb-0.5)/(1.0-contrast)+0.5;}else{color.rgb=(color.rgb-0.5)*(1.0+contrast)+0.5;}gl_FragColor=color;}\");\n    f.call(this, a.brightnessContrast, { brightness: q(-1, b, 1), contrast: q(-1, d, 1) }); return this\n  } function t(a) { a = new z(a); for (var d = [], c = 0; 256 > c; c++)d.push(q(0, Math.floor(256 * a.interpolate(c / 255)), 255)); return d } function I(b, d, c) {\n    b = t(b); 1 == arguments.length ? d = c = b : (d = t(d), c = t(c)); for (var e = [], g = 0; 256 > g; g++)e.splice(e.length, 0, b[g], d[g], c[g], 255); this._.extraTexture.initFromBytes(256, 1, e); this._.extraTexture.use(1); a.curves = a.curves || new h(null, \"uniform sampler2D texture;uniform sampler2D map;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);color.r=texture2D(map,vec2(color.r)).r;color.g=texture2D(map,vec2(color.g)).g;color.b=texture2D(map,vec2(color.b)).b;gl_FragColor=color;}\");\n    a.curves.textures({ map: 1 }); f.call(this, a.curves, {}); return this\n  } function J(b) {\n    a.denoise = a.denoise || new h(null, \"uniform sampler2D texture;uniform float exponent;uniform float strength;uniform vec2 texSize;varying vec2 texCoord;void main(){vec4 center=texture2D(texture,texCoord);vec4 color=vec4(0.0);float total=0.0;for(float x=-4.0;x<=4.0;x+=1.0){for(float y=-4.0;y<=4.0;y+=1.0){vec4 sample=texture2D(texture,texCoord+vec2(x,y)/texSize);float weight=1.0-abs(dot(sample.rgb-center.rgb,vec3(0.25)));weight=pow(weight,exponent);color+=sample*weight;total+=weight;}}gl_FragColor=color/total;}\");\n    for (var d = 0; 2 > d; d++)f.call(this, a.denoise, { exponent: Math.max(0, b), texSize: [this.width, this.height] }); return this\n  } function K(b, d) {\n    a.hueSaturation = a.hueSaturation || new h(null, \"uniform sampler2D texture;uniform float hue;uniform float saturation;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float angle=hue*3.14159265;float s=sin(angle),c=cos(angle);vec3 weights=(vec3(2.0*c,-sqrt(3.0)*s-c,sqrt(3.0)*s-c)+1.0)/3.0;float len=length(color.rgb);color.rgb=vec3(dot(color.rgb,weights.xyz),dot(color.rgb,weights.zxy),dot(color.rgb,weights.yzx));float average=(color.r+color.g+color.b)/3.0;if(saturation>0.0){color.rgb+=(average-color.rgb)*(1.0-1.0/(1.001-saturation));}else{color.rgb+=(average-color.rgb)*(-saturation);}gl_FragColor=color;}\");\n    f.call(this, a.hueSaturation, { hue: q(-1, b, 1), saturation: q(-1, d, 1) }); return this\n  } function L(b) {\n    a.noise = a.noise || new h(null, \"uniform sampler2D texture;uniform float amount;varying vec2 texCoord;float rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}void main(){vec4 color=texture2D(texture,texCoord);float diff=(rand(texCoord)-0.5)*amount;color.r+=diff;color.g+=diff;color.b+=diff;gl_FragColor=color;}\");\n    f.call(this, a.noise, { amount: q(0, b, 1) }); return this\n  } function M(b) {\n    a.sepia = a.sepia || new h(null, \"uniform sampler2D texture;uniform float amount;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float r=color.r;float g=color.g;float b=color.b;color.r=min(1.0,(r*(1.0-(0.607*amount)))+(g*(0.769*amount))+(b*(0.189*amount)));color.g=min(1.0,(r*0.349*amount)+(g*(1.0-(0.314*amount)))+(b*0.168*amount));color.b=min(1.0,(r*0.272*amount)+(g*0.534*amount)+(b*(1.0-(0.869*amount))));gl_FragColor=color;}\");\n    f.call(this, a.sepia, { amount: q(0, b, 1) }); return this\n  } function N(b, d) {\n    a.unsharpMask = a.unsharpMask || new h(null, \"uniform sampler2D blurredTexture;uniform sampler2D originalTexture;uniform float strength;uniform float threshold;varying vec2 texCoord;void main(){vec4 blurred=texture2D(blurredTexture,texCoord);vec4 original=texture2D(originalTexture,texCoord);gl_FragColor=mix(blurred,original,1.0+strength);}\");\n    this._.extraTexture.ensureFormat(this._.texture); this._.texture.use(); this._.extraTexture.drawTo(function () { h.getDefaultShader().drawRect() }); this._.extraTexture.use(1); this.triangleBlur(b); a.unsharpMask.textures({ originalTexture: 1 }); f.call(this, a.unsharpMask, { strength: d }); this._.extraTexture.unuse(1); return this\n  } function O(b) {\n    a.vibrance = a.vibrance || new h(null, \"uniform sampler2D texture;uniform float amount;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float average=(color.r+color.g+color.b)/3.0;float mx=max(color.r,max(color.g,color.b));float amt=(mx-average)*(-amount*3.0);color.rgb=mix(color.rgb,vec3(mx),amt);gl_FragColor=color;}\");\n    f.call(this, a.vibrance, { amount: q(-1, b, 1) }); return this\n  } function P(b, d) {\n    a.vignette = a.vignette || new h(null, \"uniform sampler2D texture;uniform float size;uniform float amount;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);float dist=distance(texCoord,vec2(0.5,0.5));color.rgb*=smoothstep(0.8,size*0.799,dist*(amount+size));gl_FragColor=color;}\");\n    f.call(this, a.vignette, { size: q(0, b, 1), amount: q(0, d, 1) }); return this\n  } function Q(b, d, c) {\n    a.lensBlurPrePass = a.lensBlurPrePass || new h(null, \"uniform sampler2D texture;uniform float power;varying vec2 texCoord;void main(){vec4 color=texture2D(texture,texCoord);color=pow(color,vec4(power));gl_FragColor=vec4(color);}\"); var e = \"uniform sampler2D texture0;uniform sampler2D texture1;uniform vec2 delta0;uniform vec2 delta1;uniform float power;varying vec2 texCoord;\" +\n      s + \"vec4 sample(vec2 delta){float offset=random(vec3(delta,151.7182),0.0);vec4 color=vec4(0.0);float total=0.0;for(float t=0.0;t<=30.0;t++){float percent=(t+offset)/30.0;color+=texture2D(texture0,texCoord+delta*percent);total+=1.0;}return color/total;}\";\n    a.lensBlur0 = a.lensBlur0 || new h(null, e + \"void main(){gl_FragColor=sample(delta0);}\"); a.lensBlur1 = a.lensBlur1 || new h(null, e + \"void main(){gl_FragColor=(sample(delta0)+sample(delta1))*0.5;}\"); a.lensBlur2 = a.lensBlur2 || (new h(null, e + \"void main(){vec4 color=(sample(delta0)+2.0*texture2D(texture1,texCoord))/3.0;gl_FragColor=pow(color,vec4(power));}\")).textures({ texture1: 1 }); for (var e =\n      [], g = 0; 3 > g; g++) { var l = c + 2 * g * Math.PI / 3; e.push([b * Math.sin(l) / this.width, b * Math.cos(l) / this.height]) } b = Math.pow(10, q(-1, d, 1)); f.call(this, a.lensBlurPrePass, { power: b }); this._.extraTexture.ensureFormat(this._.texture); f.call(this, a.lensBlur0, { delta0: e[0] }, this._.texture, this._.extraTexture); f.call(this, a.lensBlur1, { delta0: e[1], delta1: e[2] }, this._.extraTexture, this._.extraTexture); f.call(this, a.lensBlur0, { delta0: e[1] }); this._.extraTexture.use(1); f.call(this, a.lensBlur2, { power: 1 / b, delta0: e[2] }); return this\n  }\n  function R(b, d, c, e, g, l) {\n    a.tiltShift = a.tiltShift || new h(null, \"uniform sampler2D texture;uniform float blurRadius;uniform float gradientRadius;uniform vec2 start;uniform vec2 end;uniform vec2 delta;uniform vec2 texSize;varying vec2 texCoord;\" + s + \"void main(){vec4 color=vec4(0.0);float total=0.0;float offset=random(vec3(12.9898,78.233,151.7182),0.0);vec2 normal=normalize(vec2(start.y-end.y,end.x-start.x));float radius=smoothstep(0.0,1.0,abs(dot(texCoord*texSize-start,normal))/gradientRadius)*blurRadius;for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec4 sample=texture2D(texture,texCoord+delta/texSize*percent*radius);sample.rgb*=sample.a;color+=sample*weight;total+=weight;}gl_FragColor=color/total;gl_FragColor.rgb/=gl_FragColor.a+0.00001;}\");\n    var n = c - b, p = e - d, m = Math.sqrt(n * n + p * p); f.call(this, a.tiltShift, { blurRadius: g, gradientRadius: l, start: [b, d], end: [c, e], delta: [n / m, p / m], texSize: [this.width, this.height] }); f.call(this, a.tiltShift, { blurRadius: g, gradientRadius: l, start: [b, d], end: [c, e], delta: [-p / m, n / m], texSize: [this.width, this.height] }); return this\n  } function S(b) {\n    a.triangleBlur = a.triangleBlur || new h(null, \"uniform sampler2D texture;uniform vec2 delta;varying vec2 texCoord;\" + s + \"void main(){vec4 color=vec4(0.0);float total=0.0;float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec4 sample=texture2D(texture,texCoord+delta*percent);sample.rgb*=sample.a;color+=sample*weight;total+=weight;}gl_FragColor=color/total;gl_FragColor.rgb/=gl_FragColor.a+0.00001;}\");\n    f.call(this, a.triangleBlur, { delta: [b / this.width, 0] }); f.call(this, a.triangleBlur, { delta: [0, b / this.height] }); return this\n  } function T(b, d, c) {\n    a.zoomBlur = a.zoomBlur || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float strength;uniform vec2 texSize;varying vec2 texCoord;\" + s + \"void main(){vec4 color=vec4(0.0);float total=0.0;vec2 toCenter=center-texCoord*texSize;float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=0.0;t<=40.0;t++){float percent=(t+offset)/40.0;float weight=4.0*(percent-percent*percent);vec4 sample=texture2D(texture,texCoord+toCenter*percent*strength/texSize);sample.rgb*=sample.a;color+=sample*weight;total+=weight;}gl_FragColor=color/total;gl_FragColor.rgb/=gl_FragColor.a+0.00001;}\");\n    f.call(this, a.zoomBlur, { center: [b, d], strength: c, texSize: [this.width, this.height] }); return this\n  } function U(b, d, c, e) {\n    a.colorHalftone = a.colorHalftone || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float angle;uniform float scale;uniform vec2 texSize;varying vec2 texCoord;float pattern(float angle){float s=sin(angle),c=cos(angle);vec2 tex=texCoord*texSize-center;vec2 point=vec2(c*tex.x-s*tex.y,s*tex.x+c*tex.y)*scale;return(sin(point.x)*sin(point.y))*4.0;}void main(){vec4 color=texture2D(texture,texCoord);vec3 cmy=1.0-color.rgb;float k=min(cmy.x,min(cmy.y,cmy.z));cmy=(cmy-k)/(1.0-k);cmy=clamp(cmy*10.0-3.0+vec3(pattern(angle+0.26179),pattern(angle+1.30899),pattern(angle)),0.0,1.0);k=clamp(k*10.0-5.0+pattern(angle+0.78539),0.0,1.0);gl_FragColor=vec4(1.0-cmy-k,color.a);}\");\n    f.call(this, a.colorHalftone, { center: [b, d], angle: c, scale: Math.PI / e, texSize: [this.width, this.height] }); return this\n  } function V(b, d, c, e) {\n    a.dotScreen = a.dotScreen || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float angle;uniform float scale;uniform vec2 texSize;varying vec2 texCoord;float pattern(){float s=sin(angle),c=cos(angle);vec2 tex=texCoord*texSize-center;vec2 point=vec2(c*tex.x-s*tex.y,s*tex.x+c*tex.y)*scale;return(sin(point.x)*sin(point.y))*4.0;}void main(){vec4 color=texture2D(texture,texCoord);float average=(color.r+color.g+color.b)/3.0;gl_FragColor=vec4(vec3(average*10.0-5.0+pattern()),color.a);}\");\n    f.call(this, a.dotScreen, { center: [b, d], angle: c, scale: Math.PI / e, texSize: [this.width, this.height] }); return this\n  } function W(b) {\n    a.edgeWork1 = a.edgeWork1 || new h(null, \"uniform sampler2D texture;uniform vec2 delta;varying vec2 texCoord;\" + s + \"void main(){vec2 color=vec2(0.0);vec2 total=vec2(0.0);float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec3 sample=texture2D(texture,texCoord+delta*percent).rgb;float average=(sample.r+sample.g+sample.b)/3.0;color.x+=average*weight;total.x+=weight;if(abs(t)<15.0){weight=weight*2.0-1.0;color.y+=average*weight;total.y+=weight;}}gl_FragColor=vec4(color/total,0.0,1.0);}\");\n    a.edgeWork2 = a.edgeWork2 || new h(null, \"uniform sampler2D texture;uniform vec2 delta;varying vec2 texCoord;\" + s + \"void main(){vec2 color=vec2(0.0);vec2 total=vec2(0.0);float offset=random(vec3(12.9898,78.233,151.7182),0.0);for(float t=-30.0;t<=30.0;t++){float percent=(t+offset-0.5)/30.0;float weight=1.0-abs(percent);vec2 sample=texture2D(texture,texCoord+delta*percent).xy;color.x+=sample.x*weight;total.x+=weight;if(abs(t)<15.0){weight=weight*2.0-1.0;color.y+=sample.y*weight;total.y+=weight;}}float c=clamp(10000.0*(color.y/total.y-color.x/total.x)+0.5,0.0,1.0);gl_FragColor=vec4(c,c,c,1.0);}\");\n    f.call(this, a.edgeWork1, { delta: [b / this.width, 0] }); f.call(this, a.edgeWork2, { delta: [0, b / this.height] }); return this\n  } function X(b, d, c) {\n    a.hexagonalPixelate = a.hexagonalPixelate || new h(null, \"uniform sampler2D texture;uniform vec2 center;uniform float scale;uniform vec2 texSize;varying vec2 texCoord;void main(){vec2 tex=(texCoord*texSize-center)/scale;tex.y/=0.866025404;tex.x-=tex.y*0.5;vec2 a;if(tex.x+tex.y-floor(tex.x)-floor(tex.y)<1.0)a=vec2(floor(tex.x),floor(tex.y));else a=vec2(ceil(tex.x),ceil(tex.y));vec2 b=vec2(ceil(tex.x),floor(tex.y));vec2 c=vec2(floor(tex.x),ceil(tex.y));vec3 TEX=vec3(tex.x,tex.y,1.0-tex.x-tex.y);vec3 A=vec3(a.x,a.y,1.0-a.x-a.y);vec3 B=vec3(b.x,b.y,1.0-b.x-b.y);vec3 C=vec3(c.x,c.y,1.0-c.x-c.y);float alen=length(TEX-A);float blen=length(TEX-B);float clen=length(TEX-C);vec2 choice;if(alen<blen){if(alen<clen)choice=a;else choice=c;}else{if(blen<clen)choice=b;else choice=c;}choice.x+=choice.y*0.5;choice.y*=0.866025404;choice*=scale/texSize;gl_FragColor=texture2D(texture,choice+center/texSize);}\");\n    f.call(this, a.hexagonalPixelate, { center: [b, d], scale: c, texSize: [this.width, this.height] }); return this\n  } function Y(b) {\n    a.ink = a.ink || new h(null, \"uniform sampler2D texture;uniform float strength;uniform vec2 texSize;varying vec2 texCoord;void main(){vec2 dx=vec2(1.0/texSize.x,0.0);vec2 dy=vec2(0.0,1.0/texSize.y);vec4 color=texture2D(texture,texCoord);float bigTotal=0.0;float smallTotal=0.0;vec3 bigAverage=vec3(0.0);vec3 smallAverage=vec3(0.0);for(float x=-2.0;x<=2.0;x+=1.0){for(float y=-2.0;y<=2.0;y+=1.0){vec3 sample=texture2D(texture,texCoord+dx*x+dy*y).rgb;bigAverage+=sample;bigTotal+=1.0;if(abs(x)+abs(y)<2.0){smallAverage+=sample;smallTotal+=1.0;}}}vec3 edge=max(vec3(0.0),bigAverage/bigTotal-smallAverage/smallTotal);gl_FragColor=vec4(color.rgb-dot(edge,edge)*strength*100000.0,color.a);}\");\n    f.call(this, a.ink, { strength: b * b * b * b * b, texSize: [this.width, this.height] }); return this\n  } function Z(b, d, c, e) {\n    a.bulgePinch = a.bulgePinch || u(\"uniform float radius;uniform float strength;uniform vec2 center;\", \"coord-=center;float distance=length(coord);if(distance<radius){float percent=distance/radius;if(strength>0.0){coord*=mix(1.0,smoothstep(0.0,radius/distance,percent),strength*0.75);}else{coord*=mix(1.0,pow(percent,1.0+strength*0.75)*radius/distance,1.0-percent);}}coord+=center;\");\n    f.call(this, a.bulgePinch, { radius: c, strength: q(-1, e, 1), center: [b, d], texSize: [this.width, this.height] }); return this\n  } function $(b, d, c) {\n    a.matrixWarp = a.matrixWarp || u(\"uniform mat3 matrix;uniform bool useTextureSpace;\", \"if(useTextureSpace)coord=coord/texSize*2.0-1.0;vec3 warp=matrix*vec3(coord,1.0);coord=warp.xy/warp.z;if(useTextureSpace)coord=(coord*0.5+0.5)*texSize;\"); b = Array.prototype.concat.apply([], b); if (4 == b.length) b =\n      [b[0], b[1], 0, b[2], b[3], 0, 0, 0, 1]; else if (9 != b.length) throw \"can only warp with 2x2 or 3x3 matrix\"; f.call(this, a.matrixWarp, { matrix: d ? y(b) : b, texSize: [this.width, this.height], useTextureSpace: c | 0 }); return this\n  } function aa(a, d) {\n    var c = x.apply(null, d), e = x.apply(null, a), c = y(c); return this.matrixWarp([c[0] * e[0] + c[1] * e[3] + c[2] * e[6], c[0] * e[1] + c[1] * e[4] + c[2] * e[7], c[0] * e[2] + c[1] * e[5] + c[2] * e[8], c[3] * e[0] + c[4] * e[3] + c[5] * e[6], c[3] * e[1] + c[4] * e[4] + c[5] * e[7], c[3] * e[2] + c[4] * e[5] + c[5] * e[8], c[6] * e[0] + c[7] * e[3] + c[8] * e[6],\n    c[6] * e[1] + c[7] * e[4] + c[8] * e[7], c[6] * e[2] + c[7] * e[5] + c[8] * e[8]])\n  } function ba(b, d, c, e) {\n    a.swirl = a.swirl || u(\"uniform float radius;uniform float angle;uniform vec2 center;\", \"coord-=center;float distance=length(coord);if(distance<radius){float percent=(radius-distance)/radius;float theta=percent*percent*angle;float s=sin(theta);float c=cos(theta);coord=vec2(coord.x*c-coord.y*s,coord.x*s+coord.y*c);}coord+=center;\");\n    f.call(this, a.swirl, { radius: c, center: [b, d], angle: e, texSize: [this.width, this.height] }); return this\n  } var v = {}; (function () {\n    function a(b) {\n      if (!b.getExtension(\"OES_texture_float\")) return !1; var c = b.createFramebuffer(), e = b.createTexture(); b.bindTexture(b.TEXTURE_2D, e); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);\n      b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 1, 1, 0, b.RGBA, b.UNSIGNED_BYTE, null); b.bindFramebuffer(b.FRAMEBUFFER, c); b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, e, 0); c = b.createTexture(); b.bindTexture(b.TEXTURE_2D, c); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE); b.texImage2D(b.TEXTURE_2D,\n        0, b.RGBA, 2, 2, 0, b.RGBA, b.FLOAT, new Float32Array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])); var e = b.createProgram(), d = b.createShader(b.VERTEX_SHADER), g = b.createShader(b.FRAGMENT_SHADER); b.shaderSource(d, \"attribute vec2 vertex;void main(){gl_Position=vec4(vertex,0.0,1.0);}\"); b.shaderSource(g, \"uniform sampler2D texture;void main(){gl_FragColor=texture2D(texture,vec2(0.5));}\"); b.compileShader(d); b.compileShader(g); b.attachShader(e, d); b.attachShader(e,\n          g); b.linkProgram(e); d = b.createBuffer(); b.bindBuffer(b.ARRAY_BUFFER, d); b.bufferData(b.ARRAY_BUFFER, new Float32Array([0, 0]), b.STREAM_DRAW); b.enableVertexAttribArray(0); b.vertexAttribPointer(0, 2, b.FLOAT, !1, 0, 0); d = new Uint8Array(4); b.useProgram(e); b.viewport(0, 0, 1, 1); b.bindTexture(b.TEXTURE_2D, c); b.drawArrays(b.POINTS, 0, 1); b.readPixels(0, 0, 1, 1, b.RGBA, b.UNSIGNED_BYTE, d); return 127 === d[0] || 128 === d[0]\n    } function d() { } function c(a) {\n      \"OES_texture_float_linear\" === a ? (void 0 === this.$OES_texture_float_linear$ && Object.defineProperty(this,\n        \"$OES_texture_float_linear$\", { enumerable: !1, configurable: !1, writable: !1, value: new d }), a = this.$OES_texture_float_linear$) : a = n.call(this, a); return a\n    } function e() { var a = f.call(this); -1 === a.indexOf(\"OES_texture_float_linear\") && a.push(\"OES_texture_float_linear\"); return a } try { var g = document.createElement(\"canvas\").getContext(\"experimental-webgl\") } catch (l) { } if (g && -1 === g.getSupportedExtensions().indexOf(\"OES_texture_float_linear\") && a(g)) {\n      var n = WebGLRenderingContext.prototype.getExtension, f = WebGLRenderingContext.prototype.getSupportedExtensions;\n      WebGLRenderingContext.prototype.getExtension = c; WebGLRenderingContext.prototype.getSupportedExtensions = e\n    }\n  })(); var a; v.canvas = function () {\n    var b = document.createElement(\"canvas\"); try { a = b.getContext(\"experimental-webgl\", { premultipliedAlpha: !1 }) } catch (d) { a = null } if (!a) throw \"This browser does not support WebGL\"; b._ = { gl: a, isInitialized: !1, texture: null, spareTexture: null, flippedShader: null }; b.texture = k(A); b.draw = k(C); b.update = k(D); b.replace = k(E); b.contents = k(F); b.getPixelArray = k(G); b.brightnessContrast = k(H);\n    b.hexagonalPixelate = k(X); b.hueSaturation = k(K); b.colorHalftone = k(U); b.triangleBlur = k(S); b.unsharpMask = k(N); b.perspective = k(aa); b.matrixWarp = k($); b.bulgePinch = k(Z); b.tiltShift = k(R); b.dotScreen = k(V); b.edgeWork = k(W); b.lensBlur = k(Q); b.zoomBlur = k(T); b.noise = k(L); b.denoise = k(J); b.curves = k(I); b.swirl = k(ba); b.ink = k(Y); b.vignette = k(P); b.vibrance = k(O); b.sepia = k(M); return b\n  }; v.splineInterpolate = t; var h = function () {\n    function b(b, c) {\n      var e = a.createShader(b); a.shaderSource(e, c); a.compileShader(e); if (!a.getShaderParameter(e,\n        a.COMPILE_STATUS)) throw \"compile error: \" + a.getShaderInfoLog(e); return e\n    } function d(d, l) { this.texCoordAttribute = this.vertexAttribute = null; this.program = a.createProgram(); d = d || c; l = l || e; l = \"precision highp float;\" + l; a.attachShader(this.program, b(a.VERTEX_SHADER, d)); a.attachShader(this.program, b(a.FRAGMENT_SHADER, l)); a.linkProgram(this.program); if (!a.getProgramParameter(this.program, a.LINK_STATUS)) throw \"link error: \" + a.getProgramInfoLog(this.program); } var c = \"attribute vec2 vertex;attribute vec2 _texCoord;varying vec2 texCoord;void main(){texCoord=_texCoord;gl_Position=vec4(vertex*2.0-1.0,0.0,1.0);}\",\n      e = \"uniform sampler2D texture;varying vec2 texCoord;void main(){gl_FragColor=texture2D(texture,texCoord);}\"; d.prototype.destroy = function () { a.deleteProgram(this.program); this.program = null }; d.prototype.uniforms = function (b) {\n        a.useProgram(this.program); for (var e in b) if (b.hasOwnProperty(e)) {\n          var c = a.getUniformLocation(this.program, e); if (null !== c) {\n            var d = b[e]; if (\"[object Array]\" == Object.prototype.toString.call(d)) switch (d.length) {\n              case 1: a.uniform1fv(c, new Float32Array(d)); break;\n              case 2: a.uniform2fv(c, new Float32Array(d)); break; case 3: a.uniform3fv(c, new Float32Array(d)); break; case 4: a.uniform4fv(c, new Float32Array(d)); break; case 9: a.uniformMatrix3fv(c, !1, new Float32Array(d)); break; case 16: a.uniformMatrix4fv(c, !1, new Float32Array(d)); break; default: throw \"dont't know how to load uniform \\\"\" + e + '\" of length ' + d.length;\n            } else if (\"[object Number]\" == Object.prototype.toString.call(d)) a.uniform1f(c, d); else throw 'attempted to set uniform \"' + e + '\" to invalid value ' + (d || \"undefined\").toString();\n          }\n        } return this\n      }; d.prototype.textures = function (b) { a.useProgram(this.program); for (var c in b) b.hasOwnProperty(c) && a.uniform1i(a.getUniformLocation(this.program, c), b[c]); return this }; d.prototype.drawRect = function (b, c, e, d) {\n        var f = a.getParameter(a.VIEWPORT); c = void 0 !== c ? (c - f[1]) / f[3] : 0; b = void 0 !== b ? (b - f[0]) / f[2] : 0; e = void 0 !== e ? (e - f[0]) / f[2] : 1; d = void 0 !== d ? (d - f[1]) / f[3] : 1; null == a.vertexBuffer && (a.vertexBuffer = a.createBuffer()); a.bindBuffer(a.ARRAY_BUFFER, a.vertexBuffer); a.bufferData(a.ARRAY_BUFFER, new Float32Array([b,\n          c, b, d, e, c, e, d]), a.STATIC_DRAW); null == a.texCoordBuffer && (a.texCoordBuffer = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, a.texCoordBuffer), a.bufferData(a.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), a.STATIC_DRAW)); null == this.vertexAttribute && (this.vertexAttribute = a.getAttribLocation(this.program, \"vertex\"), a.enableVertexAttribArray(this.vertexAttribute)); null == this.texCoordAttribute && (this.texCoordAttribute = a.getAttribLocation(this.program, \"_texCoord\"), a.enableVertexAttribArray(this.texCoordAttribute));\n        a.useProgram(this.program); a.bindBuffer(a.ARRAY_BUFFER, a.vertexBuffer); a.vertexAttribPointer(this.vertexAttribute, 2, a.FLOAT, !1, 0, 0); a.bindBuffer(a.ARRAY_BUFFER, a.texCoordBuffer); a.vertexAttribPointer(this.texCoordAttribute, 2, a.FLOAT, !1, 0, 0); a.drawArrays(a.TRIANGLE_STRIP, 0, 4)\n      }; d.getDefaultShader = function () { a.defaultShader = a.defaultShader || new d; return a.defaultShader }; return d\n  }(); z.prototype.interpolate = function (a) {\n    for (var d = 0, c = this.ya.length - 1; 1 < c - d;) { var e = c + d >> 1; this.xa[e] > a ? c = e : d = e } var e = this.xa[c] -\n      this.xa[d], g = (this.xa[c] - a) / e; a = (a - this.xa[d]) / e; return g * this.ya[d] + a * this.ya[c] + ((g * g * g - g) * this.y2[d] + (a * a * a - a) * this.y2[c]) * e * e / 6\n  }; var r = function () {\n    function b(b, c, d, f) {\n      this.gl = a; this.id = a.createTexture(); this.width = b; this.height = c; this.format = d; this.type = f; a.bindTexture(a.TEXTURE_2D, this.id); a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR); a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR); a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE); a.texParameteri(a.TEXTURE_2D,\n        a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE); b && c && a.texImage2D(a.TEXTURE_2D, 0, this.format, b, c, 0, this.format, this.type, null)\n    } function d(a) { null == c && (c = document.createElement(\"canvas\")); c.width = a.width; c.height = a.height; a = c.getContext(\"2d\"); a.clearRect(0, 0, c.width, c.height); return a } b.fromElement = function (c) { var d = new b(0, 0, a.RGBA, a.UNSIGNED_BYTE); d.loadContentsOf(c); return d }; b.prototype.loadContentsOf = function (b) {\n      this.width = b.width || b.videoWidth; this.height = b.height || b.videoHeight; a.bindTexture(a.TEXTURE_2D,\n        this.id); a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, this.type, b)\n    }; b.prototype.initFromBytes = function (b, c, d) { this.width = b; this.height = c; this.format = a.RGBA; this.type = a.UNSIGNED_BYTE; a.bindTexture(a.TEXTURE_2D, this.id); a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, b, c, 0, a.RGBA, this.type, new Uint8Array(d)) }; b.prototype.destroy = function () { a.deleteTexture(this.id); this.id = null }; b.prototype.use = function (b) { a.activeTexture(a.TEXTURE0 + (b || 0)); a.bindTexture(a.TEXTURE_2D, this.id) }; b.prototype.unuse = function (b) {\n      a.activeTexture(a.TEXTURE0 +\n        (b || 0)); a.bindTexture(a.TEXTURE_2D, null)\n    }; b.prototype.ensureFormat = function (b, c, d, f) { if (1 == arguments.length) { var h = arguments[0]; b = h.width; c = h.height; d = h.format; f = h.type } if (b != this.width || c != this.height || d != this.format || f != this.type) this.width = b, this.height = c, this.format = d, this.type = f, a.bindTexture(a.TEXTURE_2D, this.id), a.texImage2D(a.TEXTURE_2D, 0, this.format, b, c, 0, this.format, this.type, null) }; b.prototype.drawTo = function (b) {\n      a.framebuffer = a.framebuffer || a.createFramebuffer(); a.bindFramebuffer(a.FRAMEBUFFER,\n        a.framebuffer); a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.id, 0); if (a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE) throw Error(\"incomplete framebuffer\"); a.viewport(0, 0, this.width, this.height); b(); a.bindFramebuffer(a.FRAMEBUFFER, null)\n    }; var c = null; b.prototype.fillUsingCanvas = function (b) { b(d(this)); this.format = a.RGBA; this.type = a.UNSIGNED_BYTE; a.bindTexture(a.TEXTURE_2D, this.id); a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, c); return this };\n    b.prototype.toImage = function (b) { this.use(); h.getDefaultShader().drawRect(); var f = 4 * this.width * this.height, k = new Uint8Array(f), n = d(this), p = n.createImageData(this.width, this.height); a.readPixels(0, 0, this.width, this.height, a.RGBA, a.UNSIGNED_BYTE, k); for (var m = 0; m < f; m++)p.data[m] = k[m]; n.putImageData(p, 0, 0); b.src = c.toDataURL() }; b.prototype.swapWith = function (a) {\n      var b; b = a.id; a.id = this.id; this.id = b; b = a.width; a.width = this.width; this.width = b; b = a.height; a.height = this.height; this.height = b; b = a.format; a.format =\n        this.format; this.format = b\n    }; return b\n  }(), s = \"float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}\";\n  v.gl = a;\n  v.simpleShader = f;\n  v.wrap = k;\n  v.Shader = h;\n  return v\n}();\nmodule.exports = fx;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./web_modules/glfx/index.js\n// module id = 0\n// module chunks = 0","// SKI GAME\n//  demo program of LocatePrint (https://github.com/abagames/LocatePrint)\n\nimport * as lp from '../locate-print/index';\nimport * as gcc from 'gcc';\n\nvar isKeyDown: boolean[];\nvar ticks: number\nvar score: number;\nvar sx: number;\nvar gateScore: number;\nvar isTitle: boolean;\nvar isGameOver: boolean;\n\nvar isEnableCapture = false;\n\nvar floor = Math.floor;\nvar random = Math.random;\n\nwindow.onload = () => {\n\t// initialize LocatePrint\n\tlp.init();\n\t// align the display to center\n\tlp.setCanvasStyle('inline');\n\t// set the pixel widht/height of the canvas\n\t// default: 640 x 480\n\tlp.setCanvasSize(640, 400);\n\t// set the color palettes (0: green, 1: white)\n\t// default: 0: black, 1: red, 2: blue 3: green\n\t//          4: yellow, 5: magenta, 6: cyan, 7: white\n\tlp.setColorPalettes(['green', 'white']);\n\t// set the character width/height of the console\n\t// default: 40 x 20\n\tlp.console(32, 16);\n\tisKeyDown = times(256, () => false);\n\twindow.onkeydown = (e: KeyboardEvent) => {\n\t\tvar kc = e.keyCode;\n\t\tisKeyDown[kc] = true;\n\t\tif (kc >= 37 && kc <= 40) {\n\t\t\te.preventDefault();\n\t\t}\n\t};\n\twindow.onkeyup = (e: KeyboardEvent) => {\n\t\tisKeyDown[e.keyCode] = false;\n\t};\n\tstartTitle();\n\trequestAnimationFrame(updateFrame);\n}\n\nfunction updateFrame() {\n\trequestAnimationFrame(updateFrame);\n\tif (isTitle) {\n\t\tupdateTitle();\n\t} else if (isGameOver) {\n\t\tupdateGameOver();\n\t} else {\n\t\tupdateGame();\n\t}\n\tlp.update();\n\tif (isEnableCapture) {\n\t\tgcc.capture(lp.fxCanvas);\n\t}\n\tticks++;\n}\n\nfunction startTitle() {\n\tticks = 0;\n\tisTitle = true;\n\t// clear the console\n\tlp.cls();\n}\n\nfunction startGame() {\n\tticks = 0;\n\tisTitle = isGameOver = false;\n\tscore = 0;\n\tgateScore = 10;\n\tsx = 16;\n\tlp.cls();\n}\n\nfunction startGameOver() {\n\tticks = 0;\n\tisGameOver = true;\n}\n\nfunction updateTitle() {\n\tif (ticks === 1 && score > 0) {\n\t\tdrawScore();\n\t}\n\tif (ticks < 60) {\n\t\tvar ts = 'SKI GAME'.substring(0, floor(ticks / 5));\n\t\t// set the character color\n\t\t// params: (foreground, background = 0)\n\t\tlp.color(0, 1);\n\t\t// set the cursor location x/y\n\t\tlp.locate(19 - ts.length, 5);\n\t\t// print the text\n\t\tlp.print(ts);\n\t} else {\n\t\tvar t = ticks % 60;\n\t\tlp.color(1);\n\t\tlp.locate(6, 10);\n\t\tif (t === 0) {\n\t\t\tlp.print('PUSH SPACE TO START');\n\t\t} else if (t === 30) {\n\t\t\tlp.print('                   ');\n\t\t}\n\t}\n\tif (isKeyDown[32]) {\n\t\tstartGame();\n\t}\n}\n\nfunction updateGame() {\n\tgateScore -= (gateScore - 10) * 0.01;\n\tvar dfc = Math.sqrt(ticks * 0.002) + 1;\n\tif (ticks % floor(6 / dfc + 1) > 0) {\n\t\treturn;\n\t}\n\tlp.locate(sx, 4);\n\tlp.color(1);\n\tlp.print('V');\n\tif (isKeyDown[37] && sx > 0) {\n\t\tsx--;\n\t}\n\tif (isKeyDown[39] && sx < 31) {\n\t\tsx++;\n\t}\n\t// scroll the console \n\tlp.scroll(0, -1);\n\tlp.color(0, 1);\n\t// get the string on the console at the specific location x/y\n\tvar cc: string = lp.screen(sx, 4);\n\tif (cc === '-') {\n\t\tlp.locate(sx + 1, 4);\n\t\tlp.print('+' + floor(gateScore));\n\t\tscore += floor(gateScore);\n\t\tgateScore += 10;\n\t} else if (cc === '[' || cc === ']') {\n\t\tstartGameOver();\n\t\treturn;\n\t}\n\tlp.locate(sx, 4);\n\tlp.print('V');\n\tlp.color(1);\n\tif (random() > 0.6 + 0.3 / dfc) {\n\t\tvar l = floor(random() * 5 + 4);\n\t\tvar x = floor(random() * (33 - l));\n\t\tvar str = '[';\n\t\tfor (let i = 0; i < l - 2; i++) {\n\t\t\tstr += '-';\n\t\t}\n\t\tstr += ']';\n\t\tlp.locate(x, 15);\n\t\tlp.print(str);\n\t}\n\tdrawScore();\n}\n\nfunction drawScore() {\n\tlp.color(1);\n\tlp.locate(0, 0);\n\tlp.print('SCORE ' + score);\n}\n\nfunction updateGameOver() {\n\tif (ticks === 1) {\n\t\tlp.color(0, 1);\n\t\tlp.locate(10, 7);\n\t\tlp.print(\"GAME OVER\");\n\t\tdrawScore();\n\t}\n\tif (ticks > 180) {\n\t\tstartTitle();\n\t}\n\tif (isKeyDown[32]) {\n\t\tstartGame();\n\t}\n}\n\nfunction times(n: number, func: Function) {\n\tlet result = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tresult.push(func(i));\n\t}\n\treturn result;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/samples/skigame.ts","// LocatePrint (https://github.com/abagames/LocatePrint)\n//  display a console of an old home computer\n\nimport * as fx from 'glfx';\nimport colorShift from './shaders/colorshift';\nimport scanlines from './shaders/scanlines';\n\nexport const scrollNone = 0;\nexport const scrollAtLastChar = 1;\nexport const scrollAtLastLine = 2;\nexport let fxCanvas: any;\nexport let canvas: HTMLCanvasElement;\nexport let consoleWidth: number;\nexport let consoleHeight: number;\nexport let cursorX = 0;\nexport let cursorY = 0;\nlet context: CanvasRenderingContext2D;\nlet colorPalettes: string[];\nlet fontName: string;\nlet texture: any;\nlet ticks = 0;\nlet texts: string[][];\nlet colors: number[][];\nlet backgroundColors: number[][];\nlet currentColor: number;\nlet currentBackgroundColor: number;\nlet textAreaPaddingX: number;\nlet textAreaPaddingY: number;\nlet textWidth: number;\nlet textHeight: number;\n\nexport function init() {\n\tfxCanvas = fx.canvas();\n\tfxCanvas.colorShift = fx.wrap(colorShift);\n\tfxCanvas.scanlines = fx.wrap(scanlines);\n\tcanvas = document.createElement('canvas');\n\tcanvas.width = 640;\n\tcanvas.height = 480;\n\tcontext = canvas.getContext('2d');\n\ttexture = fxCanvas.texture(canvas);\n\tcolorPalettes =\n\t\t['black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', 'white'];\n\tfontName = 'VT323';//Small Fonts';\n\tcurrentColor = colorPalettes.length - 1;\n\tcurrentBackgroundColor = 0;\n\tconsole(40, 20);\n\tdocument.body.appendChild(fxCanvas);\n}\n\nexport function setCanvasSize(width: number, height: number) {\n\tcanvas.width = width;\n\tcanvas.height = height;\n}\n\nexport function setCanvasStyle(style: string) {\n\tfxCanvas.style = style;\n}\n\nexport function setColorPalettes(_colorPalettes: string[] = null) {\n\tcolorPalettes = _colorPalettes;\n\tcurrentColor = _colorPalettes.length - 1;\n\tcurrentBackgroundColor = 0;\n}\n\nexport function setFontName(_fontName: string) {\n\tfontName = _fontName;\n}\n\nexport function update() {\n\trenderTexts();\n\ttexture.loadContentsOf(canvas);\n\tfxCanvas.draw(texture).\n\t\tcolorShift().\n\t\tscanlines(ticks * canvas.height * 0.000005).\n\t\tbulgePinch(canvas.width / 2, canvas.height / 2,\n\t\tcanvas.width * 0.75, 0.12).\n\t\tvignette(0.25, 0.65).\n\t\tupdate();\n\tticks++;\n}\n\nexport function console(width: number, height: number) {\n\tconsoleWidth = width;\n\tconsoleHeight = height;\n\ttexts = times(width, () => times(height, () => null));\n\tcolors = times(width, () => times(height, () => 0));\n\tbackgroundColors = times(width, () => times(height, () => 0));\n\tcls();\n}\n\nexport function locate(x: number, y: number) {\n\tcursorX = clamp(Math.floor(x), 0, consoleWidth - 1);\n\tcursorY = clamp(Math.floor(y), 0, consoleHeight - 1);\n}\n\nexport function print(text: string, scrollType: number = scrollNone) {\n\tcalcTextSize();\n\tforEach(text, (c: string) => {\n\t\tif (cursorY >= consoleHeight) {\n\t\t\treturn false;\n\t\t}\n\t\ttexts[cursorX][cursorY] = c;\n\t\tcolors[cursorX][cursorY] = currentColor;\n\t\tbackgroundColors[cursorX][cursorY] =\n\t\t\tcurrentBackgroundColor;\n\t\tcursorX++;\n\t\tif (cursorX >= consoleWidth) {\n\t\t\tcursorX = 0;\n\t\t\tcursorY++;\n\t\t\tif ((scrollType !== scrollNone &&\n\t\t\t\tcursorY >= consoleHeight)) {\n\t\t\t\tscroll(0, -1);\n\t\t\t}\n\t\t}\n\t});\n\tif (scrollType === scrollAtLastLine &&\n\t\tcursorY >= consoleHeight - 1) {\n\t\tscroll(0, -1);\n\t}\n\treturn this;\n}\n\nexport function color(foreground: number, background: number = 0) {\n\tcurrentColor = foreground;\n\tcurrentBackgroundColor = background;\n}\n\nexport function cls() {\n\ttimes(consoleHeight, (y) => {\n\t\ttimes(consoleWidth, (x) => {\n\t\t\ttexts[x][y] = null;\n\t\t});\n\t});\n\tcursorX = cursorY = 0;\n}\n\nexport function scroll(offsetX: number, offsetY: number = 0) {\n\tvar w = consoleWidth;\n\tvar h = consoleHeight;\n\tvar ntexts = times(w, () => times(h, () => null));\n\tvar ncolors = times(w, () => times(h, () => 0));\n\tvar nbackgroundColors = times(w, () => times(h, () => 0));\n\ttimes(consoleHeight, (y) => {\n\t\tvar ny = y + offsetY;\n\t\tif (ny >= 0 && ny < consoleHeight) {\n\t\t\ttimes(consoleWidth, (x) => {\n\t\t\t\tvar nx = x + offsetX;\n\t\t\t\tif (nx >= 0 && nx < consoleWidth) {\n\t\t\t\t\tntexts[nx][ny] = texts[x][y];\n\t\t\t\t\tncolors[nx][ny] = colors[x][y];\n\t\t\t\t\tnbackgroundColors[nx][ny] = backgroundColors[x][y];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\ttexts = ntexts;\n\tcolors = ncolors;\n\tbackgroundColors = nbackgroundColors;\n\tcursorX = clamp(cursorX + offsetX,\n\t\t0, consoleWidth - 1);\n\tcursorY = clamp(cursorY + offsetY,\n\t\t0, consoleHeight - 1);\n}\n\nexport function screen(x: number, y: number): string {\n\tif (x < 0 || x >= consoleWidth || y < 0 || y >= consoleHeight) {\n\t\treturn null;\n\t}\n\treturn texts[x][y];\n}\n\nfunction calcTextSize() {\n\ttextAreaPaddingX = canvas.width * 0.05;\n\ttextAreaPaddingY = canvas.height * 0.05;\n\ttextWidth =\n\t\t(canvas.width - textAreaPaddingX * 2) / consoleWidth;\n\ttextHeight =\n\t\t(canvas.height - textAreaPaddingY * 2) / consoleHeight;\n\tcontext.font =\n\t\tMath.floor(textHeight * 1.3) + 'px ' + fontName;\n\tcontext.textAlign = 'center';\n\tcontext.textBaseline = 'middle';\n}\n\nfunction renderTexts() {\n\tcalcTextSize();\n\tcontext.fillStyle = colorPalettes[0];\n\tcontext.fillRect(textAreaPaddingX, textAreaPaddingY * 0.9,\n\t\tcanvas.width - textAreaPaddingX * 2,\n\t\tcanvas.height - textAreaPaddingY * 2 * 0.9);\n\ttimes(consoleHeight, (y) => {\n\t\ttimes(consoleWidth, (x) => {\n\t\t\tdrawChar(x, y);\n\t\t});\n\t});\n}\n\nfunction drawChar(x: number, y: number) {\n\tvar c = texts[x][y];\n\tif (!c) {\n\t\treturn;\n\t}\n\tvar px = (x + 0.5) * textWidth + textAreaPaddingX;\n\tvar py = (y + 0.5) * textHeight + textAreaPaddingY;\n\tvar bClr = backgroundColors[x][y];\n\tif (bClr > 0) {\n\t\tcontext.fillStyle = colorPalettes[bClr];\n\t\tcontext.fillRect\n\t\t\t(px - textWidth / 2, py - textHeight / 2,\n\t\t\ttextWidth, textHeight);\n\t}\n\tif (c !== ' ') {\n\t\tvar clr = colors[x][y];\n\t\tcontext.fillStyle = colorPalettes[clr];\n\t\tcontext.fillText(c, px, py);\n\t}\n}\n\nfunction clamp(v: number, min: number, max: number) {\n\tif (v < min) {\n\t\treturn min;\n\t} else if (v > max) {\n\t\treturn max;\n\t} else {\n\t\treturn v;\n\t}\n}\n\nfunction times(n: number, func: Function) {\n\tlet result = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tresult.push(func(i));\n\t}\n\treturn result;\n}\n\nfunction forEach(array: any[] | string, func: Function) {\n\tlet result = [];\n\tfor (let i = 0; i < array.length; i++) {\n\t\tresult.push(func(array[i]));\n\t}\n\treturn result;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/locate-print/index.ts","import * as fx from 'glfx';\n\nexport default function colorShift() {\n\tvar shader = new fx.Shader(null, '\\\n\t\tuniform sampler2D texture;\\\n\t\tuniform float texSizeX;\\\n\t\tvarying vec2 texCoord;\\\n\t\t\\\n\t\tvoid main() {\\\n\t\t\tvec2 ofs = vec2(2.0 / texSizeX, 0.0);\\\n\t\t\tvec4 pl = texture2D(texture, texCoord - ofs);\\\n\t\t\tvec4 pc = texture2D(texture, texCoord);\\\n\t\t\tvec4 pr = texture2D(texture, texCoord + ofs);\\\n\t\t\tgl_FragColor = vec4(pl.r, pc.g, pr.b, pc.a);\\\n\t\t}\\\n\t');\n\tfx.simpleShader.call(this, shader, {\n\t\ttexSizeX: this.width\n\t});\n\treturn this;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/locate-print/shaders/colorshift.ts","import * as fx from 'glfx';\n\nexport default function scanlines(offset) {\n\tvar shader = new fx.Shader(null, '\\\n\t\tuniform sampler2D texture;\\\n\t\tuniform float texSizeY;\\\n\t\tuniform float offset;\\\n\t\tvarying vec2 texCoord;\\\n\t\t\\\n\t\tvoid main() {\\\n\t\t\tvec4 p = texture2D(texture, texCoord);\\\n\t\t\tfloat br = clamp(sin((texCoord.y + offset) / texSizeY * 50000.0) *\\\n\t\t\t\t0.1 + 1.0, 0.0, 1.0);\\\n\t\t\tp.rgb *= br;\\\n\t\t\tgl_FragColor = p;\\\n\t\t}\\\n\t');\n\tfx.simpleShader.call(this, shader, {\n\t\ttexSizeY: this.height,\n\t\toffset: offset\n\t});\n\treturn this;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/locate-print/shaders/scanlines.ts","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gcc\"] = factory();\n\telse\n\t\troot[\"gcc\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar GIFEncoder = __webpack_require__(2);\n\texports.options = {\n\t    scale: 0.5,\n\t    durationSec: 3,\n\t    keyCode: 67,\n\t    capturingFps: 20,\n\t    appFps: 60,\n\t    isAppendingImgElement: true,\n\t    quality: 10,\n\t    downloadFileName: null\n\t};\n\tvar contextsNum;\n\tvar contexts;\n\tvar isCaptured;\n\tvar index = 0;\n\tvar frameCount = 0;\n\tvar image = new Image();\n\tvar isInfiniteDuration = false;\n\tfunction capture(element) {\n\t    frameCount++;\n\t    var capturePerFrame = exports.options.appFps / exports.options.capturingFps;\n\t    if (frameCount < capturePerFrame) {\n\t        return;\n\t    }\n\t    frameCount -= capturePerFrame;\n\t    if (!contexts) {\n\t        begin(element);\n\t    }\n\t    if (isInfiniteDuration) {\n\t        contexts.push(createContext(element));\n\t    }\n\t    contexts[index].drawImage(element, 0, 0);\n\t    if (!isInfiniteDuration) {\n\t        isCaptured[index] = true;\n\t    }\n\t    index++;\n\t    if (!isInfiniteDuration && index >= contextsNum) {\n\t        index = 0;\n\t    }\n\t}\n\texports.capture = capture;\n\tfunction captureSvg(svgElm) {\n\t    var capturePerFrame = exports.options.appFps / exports.options.capturingFps;\n\t    if (frameCount + 1 < capturePerFrame) {\n\t        frameCount++;\n\t        return;\n\t    }\n\t    var svgXml = new XMLSerializer().serializeToString(svgElm);\n\t    image.src = \"data:image/svg+xml;base64,\" + btoa(svgXml);\n\t    capture(image);\n\t}\n\texports.captureSvg = captureSvg;\n\tfunction begin(element) {\n\t    if (isInfiniteDuration) {\n\t        contexts = [];\n\t    }\n\t    else {\n\t        contextsNum = exports.options.durationSec * exports.options.capturingFps;\n\t        contexts = times(contextsNum, function () { return createContext(element); });\n\t        isCaptured = times(contextsNum, function () { return false; });\n\t    }\n\t    document.addEventListener('keydown', function (e) {\n\t        if (e.keyCode == exports.options.keyCode) {\n\t            end();\n\t        }\n\t    });\n\t}\n\tfunction createContext(element) {\n\t    var cvs = document.createElement('canvas');\n\t    cvs.width = element.width * exports.options.scale;\n\t    cvs.height = element.height * exports.options.scale;\n\t    var ctx = cvs.getContext('2d');\n\t    ctx.scale(exports.options.scale, exports.options.scale);\n\t    return ctx;\n\t}\n\tfunction end() {\n\t    var encoder = new GIFEncoder();\n\t    encoder.setRepeat(0);\n\t    encoder.setDelay(1000 / exports.options.capturingFps);\n\t    encoder.setQuality(exports.options.quality);\n\t    encoder.start();\n\t    if (isInfiniteDuration) {\n\t        times(index - 1, function (i) {\n\t            encoder.addFrame(contexts[i]);\n\t        });\n\t    }\n\t    else {\n\t        var idx_1 = index;\n\t        times(contextsNum, function () {\n\t            if (isCaptured[idx_1]) {\n\t                encoder.addFrame(contexts[idx_1]);\n\t            }\n\t            idx_1++;\n\t            if (idx_1 >= contextsNum) {\n\t                idx_1 = 0;\n\t            }\n\t        });\n\t    }\n\t    encoder.finish();\n\t    if (exports.options.downloadFileName != null) {\n\t        encoder.download(exports.options.downloadFileName);\n\t        return null;\n\t    }\n\t    var binaryGif = encoder.stream().getData();\n\t    var imgElement = document.createElement('img');\n\t    imgElement.src = 'data:image/gif;base64,' + encode64(binaryGif);\n\t    if (exports.options.isAppendingImgElement) {\n\t        document.getElementsByTagName('body')[0].appendChild(imgElement);\n\t    }\n\t    return imgElement;\n\t}\n\texports.end = end;\n\tfunction times(n, func) {\n\t    var result = [];\n\t    for (var i = 0; i < n; i++) {\n\t        result.push(func(i));\n\t    }\n\t    return result;\n\t}\n\tfunction setOptions(_options) {\n\t    for (var attr in _options) {\n\t        exports.options[attr] = _options[attr];\n\t    }\n\t    isInfiniteDuration = exports.options.durationSec <= 0;\n\t}\n\texports.setOptions = setOptions;\n\t// https://github.com/antimatter15/jsgif/blob/master/b64.js\n\tfunction encode64(input) {\n\t    var output = \"\", i = 0, l = input.length, key = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\t    while (i < l) {\n\t        chr1 = input.charCodeAt(i++);\n\t        chr2 = input.charCodeAt(i++);\n\t        chr3 = input.charCodeAt(i++);\n\t        enc1 = chr1 >> 2;\n\t        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t        enc4 = chr3 & 63;\n\t        if (isNaN(chr2))\n\t            enc3 = enc4 = 64;\n\t        else if (isNaN(chr3))\n\t            enc4 = 64;\n\t        output = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);\n\t    }\n\t    return output;\n\t}\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This class lets you encode animated GIF files\n\t * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\n\t * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n\t * @author Thibault Imbert (AS3 version - bytearray.org)\n\t * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n\t * @version 0.1 AS3 implementation\n\t */\n\n\tGIFEncoder = function () {\n\n\t  for (var i = 0, chr = {}; i < 256; i++)\n\t    chr[i] = String.fromCharCode(i);\n\n\t  function ByteArray() {\n\t    this.bin = [];\n\t  }\n\n\t  ByteArray.prototype.getData = function () {\n\t    for (var v = '', l = this.bin.length, i = 0; i < l; i++)\n\t      v += chr[this.bin[i]];\n\t    return v;\n\t  };\n\n\t  ByteArray.prototype.writeByte = function (val) {\n\t    this.bin.push(val);\n\t  };\n\n\t  ByteArray.prototype.writeUTFBytes = function (string) {\n\t    for (var l = string.length, i = 0; i < l; i++)\n\t      this.writeByte(string.charCodeAt(i));\n\t  };\n\n\t  ByteArray.prototype.writeBytes = function (array, offset, length) {\n\t    for (var l = length || array.length, i = offset || 0; i < l; i++)\n\t      this.writeByte(array[i]);\n\t  };\n\n\t  var exports = {};\n\t  var width; // image size\n\t  var height;\n\t  var transparent = null; // transparent color if given\n\t  var transIndex; // transparent index in color table\n\t  var repeat = -1; // no repeat\n\t  var delay = 0; // frame delay (hundredths)\n\t  var started = false; // ready to output frames\n\t  var out;\n\t  var image; // current frame\n\t  var pixels; // BGR byte array from frame\n\t  var indexedPixels; // converted frame indexed to palette\n\t  var colorDepth; // number of bit planes\n\t  var colorTab; // RGB palette\n\t  var usedEntry = []; // active palette entries\n\t  var palSize = 7; // color table size (bits-1)\n\t  var dispose = -1; // disposal code (-1 = use default)\n\t  var closeStream = false; // close stream when finished\n\t  var firstFrame = true;\n\t  var sizeSet = false; // if false, get size from first frame\n\t  var sample = 10; // default sample interval for quantizer\n\t  var comment = \"Generated by jsgif (https://github.com/antimatter15/jsgif/)\"; // default comment for generated gif\n\n\t\t/**\n\t\t * Sets the delay time between each frame, or changes it for subsequent frames\n\t\t * (applies to last frame added)\n\t\t * int delay time in milliseconds\n\t\t * @param ms\n\t\t */\n\n\t  var setDelay = exports.setDelay = function setDelay(ms) {\n\t    delay = Math.round(ms / 10);\n\t  };\n\n\t\t/**\n\t\t * Sets the GIF frame disposal code for the last added frame and any\n\t\t *\n\t\t * subsequent frames. Default is 0 if no transparent color has been set,\n\t\t * otherwise 2.\n\t\t * @param code\n\t\t * int disposal code.\n\t\t */\n\n\t  var setDispose = exports.setDispose = function setDispose(code) {\n\t    if (code >= 0) dispose = code;\n\t  };\n\n\t\t/**\n\t\t * Sets the number of times the set of GIF frames should be played. Default is\n\t\t * 1; 0 means play indefinitely. Must be invoked before the first image is\n\t\t * added.\n\t\t *\n\t\t * @param iter\n\t\t * int number of iterations.\n\t\t * @return\n\t\t */\n\n\t  var setRepeat = exports.setRepeat = function setRepeat(iter) {\n\t    if (iter >= 0) repeat = iter;\n\t  };\n\n\t\t/**\n\t\t * Sets the transparent color for the last added frame and any subsequent\n\t\t * frames. Since all colors are subject to modification in the quantization\n\t\t * process, the color in the final palette for each frame closest to the given\n\t\t * color becomes the transparent color for that frame. May be set to null to\n\t\t * indicate no transparent color.\n\t\t * @param\n\t\t * Color to be treated as transparent on display.\n\t\t */\n\n\t  var setTransparent = exports.setTransparent = function setTransparent(c) {\n\t    transparent = c;\n\t  };\n\n\n\t\t/**\n\t\t * Sets the comment for the block comment\n\t\t * @param\n\t\t * string to be insterted as comment\n\t\t */\n\n\t  var setComment = exports.setComment = function setComment(c) {\n\t    comment = c;\n\t  };\n\n\n\n\t\t/**\n\t\t * The addFrame method takes an incoming BitmapData object to create each frames\n\t\t * @param\n\t\t * BitmapData object to be treated as a GIF's frame\n\t\t */\n\n\t  var addFrame = exports.addFrame = function addFrame(im, is_imageData) {\n\n\t    if ((im === null) || !started || out === null) {\n\t      throw new Error(\"Please call start method before calling addFrame\");\n\t    }\n\n\t    var ok = true;\n\n\t    try {\n\t      if (!is_imageData) {\n\t        image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;\n\t        if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\n\t      } else {\n\t        if (im instanceof ImageData) {\n\t          image = im.data;\n\t          if (!sizeset || width != im.width || height != im.height) {\n\t            setSize(im.width, im.height);\n\t          } else {\n\n\t          }\n\t        } else if (im instanceof Uint8ClampedArray) {\n\t          if (im.length == (width * height * 4)) {\n\t            image = im;\n\t          } else {\n\t            console.log(\"Please set the correct size: ImageData length mismatch\");\n\t            ok = false;\n\t          }\n\t        } else {\n\t          console.log(\"Please provide correct input\");\n\t          ok = false;\n\t        }\n\t      }\n\t      getImagePixels(); // convert to correct format if necessary\n\t      analyzePixels(); // build color table & map pixels\n\n\t      if (firstFrame) {\n\t        writeLSD(); // logical screen descriptior\n\t        writePalette(); // global color table\n\t        if (repeat >= 0) {\n\t          // use NS app extension to indicate reps\n\t          writeNetscapeExt();\n\t        }\n\t      }\n\n\t      writeGraphicCtrlExt(); // write graphic control extension\n\t      if (comment !== '') {\n\t        writeCommentExt(); // write comment extension\n\t      }\n\t      writeImageDesc(); // image descriptor\n\t      if (!firstFrame) writePalette(); // local color table\n\t      writePixels(); // encode and write pixel data\n\t      firstFrame = false;\n\t    } catch (e) {\n\t      ok = false;\n\t    }\n\n\t    return ok;\n\t  };\n\n\t\t/**\n\t\t* @description: Downloads the encoded gif with the given name\n\t\t* No need of any conversion from the stream data (out) to base64\n\t\t* Solves the issue of large file sizes when there are more frames\n\t\t* and does not involve in creation of any temporary data in the process\n\t\t* so no wastage of memory, and speeds up the process of downloading\n\t\t* to just calling this function.\n\t\t* @parameter {String} filename filename used for downloading the gif\n\t\t*/\n\n\t  var download = exports.download = function download(filename) {\n\t    if (out === null || closeStream == false) {\n\t      console.log(\"Please call start method and add frames and call finish method before calling download\");\n\t    } else {\n\t      filename = filename !== undefined ? (filename.endsWith(\".gif\") ? filename : filename + \".gif\") : \"download.gif\";\n\t      var templink = document.createElement(\"a\");\n\t      templink.download = filename;\n\t      templink.href = URL.createObjectURL(new Blob([new Uint8Array(out.bin)], { type: \"image/gif\" }));\n\t      templink.click();\n\t    }\n\t  }\n\n\t\t/**\n\t\t * Adds final trailer to the GIF stream, if you don't call the finish method\n\t\t * the GIF stream will not be valid.\n\t\t */\n\n\t  var finish = exports.finish = function finish() {\n\n\t    if (!started) return false;\n\n\t    var ok = true;\n\t    started = false;\n\n\t    try {\n\t      out.writeByte(0x3b); // gif trailer\n\t      closeStream = true;\n\t    } catch (e) {\n\t      ok = false;\n\t    }\n\n\t    return ok;\n\t  };\n\n\t\t/**\n\t\t * Resets some members so that a new stream can be started.\n\t\t * This method is actually called by the start method\n\t\t */\n\n\t  var reset = function reset() {\n\n\t    // reset for subsequent use\n\t    transIndex = 0;\n\t    image = null;\n\t    pixels = null;\n\t    indexedPixels = null;\n\t    colorTab = null;\n\t    closeStream = false;\n\t    firstFrame = true;\n\t  };\n\n\t\t/**\n\t\t * * Sets frame rate in frames per second. Equivalent to\n\t\t * <code>setDelay(1000/fps)</code>.\n\t\t * @param fps\n\t\t * float frame rate (frames per second)\n\t\t */\n\n\t  var setFrameRate = exports.setFrameRate = function setFrameRate(fps) {\n\t    if (fps != 0xf) delay = Math.round(100 / fps);\n\t  };\n\n\t\t/**\n\t\t * Sets quality of color quantization (conversion of images to the maximum 256\n\t\t * colors allowed by the GIF specification). Lower values (minimum = 1)\n\t\t * produce better colors, but slow processing significantly. 10 is the\n\t\t * default, and produces good color mapping at reasonable speeds. Values\n\t\t * greater than 20 do not yield significant improvements in speed.\n\t\t * @param quality\n\t\t * int greater than 0.\n\t\t * @return\n\t\t */\n\n\t  var setQuality = exports.setQuality = function setQuality(quality) {\n\t    if (quality < 1) quality = 1;\n\t    sample = quality;\n\t  };\n\n\t\t/**\n\t\t * Sets the GIF frame size. The default size is the size of the first frame\n\t\t * added if this method is not invoked.\n\t\t * @param w\n\t\t * int frame width.\n\t\t * @param h\n\t\t * int frame width.\n\t\t */\n\n\t  var setSize = exports.setSize = function setSize(w, h) {\n\n\t    if (started && !firstFrame) return;\n\t    width = w;\n\t    height = h;\n\t    if (width < 1) width = 320;\n\t    if (height < 1) height = 240;\n\t    sizeSet = true;\n\t  };\n\n\t\t/**\n\t\t * Initiates GIF file creation on the given stream.\n\t\t * @param os\n\t\t * OutputStream on which GIF images are written.\n\t\t * @return false if initial write failed.\n\t\t */\n\n\t  var start = exports.start = function start() {\n\n\t    reset();\n\t    var ok = true;\n\t    closeStream = false;\n\t    out = new ByteArray();\n\t    try {\n\t      out.writeUTFBytes(\"GIF89a\"); // header\n\t    } catch (e) {\n\t      ok = false;\n\t    }\n\n\t    return started = ok;\n\t  };\n\n\t  var cont = exports.cont = function cont() {\n\n\t    reset();\n\t    var ok = true;\n\t    closeStream = false;\n\t    out = new ByteArray();\n\n\t    return started = ok;\n\t  };\n\n\t\t/**\n\t\t * Analyzes image colors and creates color map.\n\t\t */\n\n\t  var analyzePixels = function analyzePixels() {\n\n\t    var len = pixels.length;\n\t    var nPix = len / 3;\n\t    indexedPixels = [];\n\t    var nq = new NeuQuant(pixels, len, sample);\n\n\t    // initialize quantizer\n\t    colorTab = nq.process(); // create reduced palette\n\n\t    // map image pixels to new palette\n\t    var k = 0;\n\t    for (var j = 0; j < nPix; j++) {\n\t      var index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\n\t      usedEntry[index] = true;\n\t      indexedPixels[j] = index;\n\t    }\n\n\t    pixels = null;\n\t    colorDepth = 8;\n\t    palSize = 7;\n\n\t    // get closest match to transparent color if specified\n\t    if (transparent !== null) {\n\t      transIndex = findClosest(transparent);\n\t    }\n\t  };\n\n\t\t/**\n\t\t * Returns index of palette color closest to c\n\t\t */\n\n\t  var findClosest = function findClosest(c) {\n\n\t    if (colorTab === null) return -1;\n\t    var r = (c & 0xFF0000) >> 16;\n\t    var g = (c & 0x00FF00) >> 8;\n\t    var b = (c & 0x0000FF);\n\t    var minpos = 0;\n\t    var dmin = 256 * 256 * 256;\n\t    var len = colorTab.length;\n\n\t    for (var i = 0; i < len;) {\n\t      var dr = r - (colorTab[i++] & 0xff);\n\t      var dg = g - (colorTab[i++] & 0xff);\n\t      var db = b - (colorTab[i] & 0xff);\n\t      var d = dr * dr + dg * dg + db * db;\n\t      var index = i / 3;\n\t      if (usedEntry[index] && (d < dmin)) {\n\t        dmin = d;\n\t        minpos = index;\n\t      }\n\t      i++;\n\t    }\n\t    return minpos;\n\t  };\n\n\t\t/**\n\t\t * Extracts image pixels into byte array \"pixels\n\t\t */\n\n\t  var getImagePixels = function getImagePixels() {\n\t    var w = width;\n\t    var h = height;\n\t    pixels = [];\n\t    var data = image;\n\t    var count = 0;\n\n\t    for (var i = 0; i < h; i++) {\n\n\t      for (var j = 0; j < w; j++) {\n\n\t        var b = (i * w * 4) + j * 4;\n\t        pixels[count++] = data[b];\n\t        pixels[count++] = data[b + 1];\n\t        pixels[count++] = data[b + 2];\n\n\t      }\n\n\t    }\n\t  };\n\n\t\t/**\n\t\t * Writes Graphic Control Extension\n\t\t */\n\n\t  var writeGraphicCtrlExt = function writeGraphicCtrlExt() {\n\t    out.writeByte(0x21); // extension introducer\n\t    out.writeByte(0xf9); // GCE label\n\t    out.writeByte(4); // data block size\n\t    var transp;\n\t    var disp;\n\t    if (transparent === null) {\n\t      transp = 0;\n\t      disp = 0; // dispose = no action\n\t    } else {\n\t      transp = 1;\n\t      disp = 2; // force clear if using transparent color\n\t    }\n\t    if (dispose >= 0) {\n\t      disp = dispose & 7; // user override\n\t    }\n\t    disp <<= 2;\n\t    // packed fields\n\t    out.writeByte(0 | // 1:3 reserved\n\t      disp | // 4:6 disposal\n\t      0 | // 7 user input - 0 = none\n\t      transp); // 8 transparency flag\n\n\t    WriteShort(delay); // delay x 1/100 sec\n\t    out.writeByte(transIndex); // transparent color index\n\t    out.writeByte(0); // block terminator\n\t  };\n\n\t\t/**\n\t\t * Writes Comment Extention\n\t\t */\n\n\t  var writeCommentExt = function writeCommentExt() {\n\t    out.writeByte(0x21); // extension introducer\n\t    out.writeByte(0xfe); // comment label\n\t    out.writeByte(comment.length); // Block Size (s)\n\t    out.writeUTFBytes(comment);\n\t    out.writeByte(0); // block terminator\n\t  };\n\n\n\t\t/**\n\t\t * Writes Image Descriptor\n\t\t */\n\n\t  var writeImageDesc = function writeImageDesc() {\n\n\t    out.writeByte(0x2c); // image separator\n\t    WriteShort(0); // image position x,y = 0,0\n\t    WriteShort(0);\n\t    WriteShort(width); // image size\n\t    WriteShort(height);\n\n\t    // packed fields\n\t    if (firstFrame) {\n\t      // no LCT - GCT is used for first (or only) frame\n\t      out.writeByte(0);\n\t    } else {\n\t      // specify normal LCT\n\t      out.writeByte(0x80 | // 1 local color table 1=yes\n\t        0 | // 2 interlace - 0=no\n\t        0 | // 3 sorted - 0=no\n\t        0 | // 4-5 reserved\n\t        palSize); // 6-8 size of color table\n\t    }\n\t  };\n\n\t\t/**\n\t\t * Writes Logical Screen Descriptor\n\t\t */\n\n\t  var writeLSD = function writeLSD() {\n\n\t    // logical screen size\n\t    WriteShort(width);\n\t    WriteShort(height);\n\t    // packed fields\n\t    out.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)\n\t      0x70 | // 2-4 : color resolution = 7\n\t      0x00 | // 5 : gct sort flag = 0\n\t      palSize)); // 6-8 : gct size\n\n\t    out.writeByte(0); // background color index\n\t    out.writeByte(0); // pixel aspect ratio - assume 1:1\n\t  };\n\n\t\t/**\n\t\t * Writes Netscape application extension to define repeat count.\n\t\t */\n\n\t  var writeNetscapeExt = function writeNetscapeExt() {\n\t    out.writeByte(0x21); // extension introducer\n\t    out.writeByte(0xff); // app extension label\n\t    out.writeByte(11); // block size\n\t    out.writeUTFBytes(\"NETSCAPE\" + \"2.0\"); // app id + auth code\n\t    out.writeByte(3); // sub-block size\n\t    out.writeByte(1); // loop sub-block id\n\t    WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\n\t    out.writeByte(0); // block terminator\n\t  };\n\n\t\t/**\n\t\t * Writes color table\n\t\t */\n\n\t  var writePalette = function writePalette() {\n\t    out.writeBytes(colorTab);\n\t    var n = (3 * 256) - colorTab.length;\n\t    for (var i = 0; i < n; i++) out.writeByte(0);\n\t  };\n\n\t  var WriteShort = function WriteShort(pValue) {\n\t    out.writeByte(pValue & 0xFF);\n\t    out.writeByte((pValue >> 8) & 0xFF);\n\t  };\n\n\t\t/**\n\t\t * Encodes and writes pixel data\n\t\t */\n\n\t  var writePixels = function writePixels() {\n\t    var myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);\n\t    myencoder.encode(out);\n\t  };\n\n\t\t/**\n\t\t * Retrieves the GIF stream\n\t\t */\n\n\t  var stream = exports.stream = function stream() {\n\t    return out;\n\t  };\n\n\t  var setProperties = exports.setProperties = function setProperties(has_start, is_first) {\n\t    started = has_start;\n\t    firstFrame = is_first;\n\t  };\n\n\t  return exports;\n\n\t};\n\n\tmodule.exports = GIFEncoder;\n\n\t/**\n\t * This class handles LZW encoding\n\t * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\n\t * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n\t * @author Thibault Imbert (AS3 version - bytearray.org)\n\t * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n\t * @version 0.1 AS3 implementation\n\t */\n\n\tLZWEncoder = function () {\n\n\t  var exports = {};\n\t  var EOF = -1;\n\t  var imgW;\n\t  var imgH;\n\t  var pixAry;\n\t  var initCodeSize;\n\t  var remaining;\n\t  var curPixel;\n\n\t  // GIFCOMPR.C - GIF Image compression routines\n\t  // Lempel-Ziv compression based on 'compress'. GIF modifications by\n\t  // David Rowley (mgardi@watdcsu.waterloo.edu)\n\t  // General DEFINEs\n\n\t  var BITS = 12;\n\t  var HSIZE = 5003; // 80% occupancy\n\n\t  // GIF Image compression - modified 'compress'\n\t  // Based on: compress.c - File compression ala IEEE Computer, June 1984.\n\t  // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n\t  // Jim McKie (decvax!mcvax!jim)\n\t  // Steve Davies (decvax!vax135!petsd!peora!srd)\n\t  // Ken Turkowski (decvax!decwrl!turtlevax!ken)\n\t  // James A. Woods (decvax!ihnp4!ames!jaw)\n\t  // Joe Orost (decvax!vax135!petsd!joe)\n\n\t  var n_bits; // number of bits/code\n\t  var maxbits = BITS; // user settable max # bits/code\n\t  var maxcode; // maximum code, given n_bits\n\t  var maxmaxcode = 1 << BITS; // should NEVER generate this code\n\t  var htab = [];\n\t  var codetab = [];\n\t  var hsize = HSIZE; // for dynamic table sizing\n\t  var free_ent = 0; // first unused entry\n\n\t  // block compression parameters -- after all codes are used up,\n\t  // and compression rate changes, start over.\n\n\t  var clear_flg = false;\n\n\t  // Algorithm: use open addressing double hashing (no chaining) on the\n\t  // prefix code / next character combination. We do a variant of Knuth's\n\t  // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n\t  // secondary probe. Here, the modular division first probe is gives way\n\t  // to a faster exclusive-or manipulation. Also do block compression with\n\t  // an adaptive reset, whereby the code table is cleared when the compression\n\t  // ratio decreases, but after the table fills. The variable-length output\n\t  // codes are re-sized at this point, and a special CLEAR code is generated\n\t  // for the decompressor. Late addition: construct the table according to\n\t  // file size for noticeable speed improvement on small files. Please direct\n\t  // questions about this implementation to ames!jaw.\n\n\t  var g_init_bits;\n\t  var ClearCode;\n\t  var EOFCode;\n\n\t  // output\n\t  // Output the given code.\n\t  // Inputs:\n\t  // code: A n_bits-bit integer. If == -1, then EOF. This assumes\n\t  // that n_bits =< wordsize - 1.\n\t  // Outputs:\n\t  // Outputs code to the file.\n\t  // Assumptions:\n\t  // Chars are 8 bits long.\n\t  // Algorithm:\n\t  // Maintain a BITS character long buffer (so that 8 codes will\n\t  // fit in it exactly). Use the VAX insv instruction to insert each\n\t  // code in turn. When the buffer fills up empty it and start over.\n\n\t  var cur_accum = 0;\n\t  var cur_bits = 0;\n\t  var masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\n\n\t  // Number of characters so far in this 'packet'\n\t  var a_count;\n\n\t  // Define the storage for the packet accumulator\n\t  var accum = [];\n\n\t  var LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\n\t    imgW = width;\n\t    imgH = height;\n\t    pixAry = pixels;\n\t    initCodeSize = Math.max(2, color_depth);\n\t  };\n\n\t  // Add a character to the end of the current packet, and if it is 254\n\t  // characters, flush the packet to disk.\n\t  var char_out = function char_out(c, outs) {\n\t    accum[a_count++] = c;\n\t    if (a_count >= 254) flush_char(outs);\n\t  };\n\n\t  // Clear out the hash table\n\t  // table clear for block compress\n\n\t  var cl_block = function cl_block(outs) {\n\t    cl_hash(hsize);\n\t    free_ent = ClearCode + 2;\n\t    clear_flg = true;\n\t    output(ClearCode, outs);\n\t  };\n\n\t  // reset code table\n\t  var cl_hash = function cl_hash(hsize) {\n\t    for (var i = 0; i < hsize; ++i) htab[i] = -1;\n\t  };\n\n\t  var compress = exports.compress = function compress(init_bits, outs) {\n\n\t    var fcode;\n\t    var i; /* = 0 */\n\t    var c;\n\t    var ent;\n\t    var disp;\n\t    var hsize_reg;\n\t    var hshift;\n\n\t    // Set up the globals: g_init_bits - initial number of bits\n\t    g_init_bits = init_bits;\n\n\t    // Set up the necessary values\n\t    clear_flg = false;\n\t    n_bits = g_init_bits;\n\t    maxcode = MAXCODE(n_bits);\n\n\t    ClearCode = 1 << (init_bits - 1);\n\t    EOFCode = ClearCode + 1;\n\t    free_ent = ClearCode + 2;\n\n\t    a_count = 0; // clear packet\n\n\t    ent = nextPixel();\n\n\t    hshift = 0;\n\t    for (fcode = hsize; fcode < 65536; fcode *= 2)\n\t      ++hshift;\n\t    hshift = 8 - hshift; // set hash code range bound\n\n\t    hsize_reg = hsize;\n\t    cl_hash(hsize_reg); // clear hash table\n\n\t    output(ClearCode, outs);\n\n\t    outer_loop: while ((c = nextPixel()) != EOF) {\n\t      fcode = (c << maxbits) + ent;\n\t      i = (c << hshift) ^ ent; // xor hashing\n\n\t      if (htab[i] == fcode) {\n\t        ent = codetab[i];\n\t        continue;\n\t      }\n\n\t      else if (htab[i] >= 0) { // non-empty slot\n\n\t        disp = hsize_reg - i; // secondary hash (after G. Knott)\n\t        if (i === 0) disp = 1;\n\n\t        do {\n\t          if ((i -= disp) < 0)\n\t            i += hsize_reg;\n\n\t          if (htab[i] == fcode) {\n\t            ent = codetab[i];\n\t            continue outer_loop;\n\t          }\n\t        } while (htab[i] >= 0);\n\t      }\n\n\t      output(ent, outs);\n\t      ent = c;\n\t      if (free_ent < maxmaxcode) {\n\t        codetab[i] = free_ent++; // code -> hashtable\n\t        htab[i] = fcode;\n\t      }\n\t      else cl_block(outs);\n\t    }\n\n\t    // Put out the final code.\n\t    output(ent, outs);\n\t    output(EOFCode, outs);\n\t  };\n\n\t  // ----------------------------------------------------------------------------\n\t  var encode = exports.encode = function encode(os) {\n\t    os.writeByte(initCodeSize); // write \"initial code size\" byte\n\t    remaining = imgW * imgH; // reset navigation variables\n\t    curPixel = 0;\n\t    compress(initCodeSize + 1, os); // compress and write the pixel data\n\t    os.writeByte(0); // write block terminator\n\t  };\n\n\t  // Flush the packet to disk, and reset the accumulator\n\t  var flush_char = function flush_char(outs) {\n\t    if (a_count > 0) {\n\t      outs.writeByte(a_count);\n\t      outs.writeBytes(accum, 0, a_count);\n\t      a_count = 0;\n\t    }\n\t  };\n\n\t  var MAXCODE = function MAXCODE(n_bits) {\n\t    return (1 << n_bits) - 1;\n\t  };\n\n\t  // ----------------------------------------------------------------------------\n\t  // Return the next pixel from the image\n\t  // ----------------------------------------------------------------------------\n\n\t  var nextPixel = function nextPixel() {\n\t    if (remaining === 0) return EOF;\n\t    --remaining;\n\t    var pix = pixAry[curPixel++];\n\t    return pix & 0xff;\n\t  };\n\n\t  var output = function output(code, outs) {\n\n\t    cur_accum &= masks[cur_bits];\n\n\t    if (cur_bits > 0) cur_accum |= (code << cur_bits);\n\t    else cur_accum = code;\n\n\t    cur_bits += n_bits;\n\n\t    while (cur_bits >= 8) {\n\t      char_out((cur_accum & 0xff), outs);\n\t      cur_accum >>= 8;\n\t      cur_bits -= 8;\n\t    }\n\n\t    // If the next entry is going to be too big for the code size,\n\t    // then increase it, if possible.\n\n\t    if (free_ent > maxcode || clear_flg) {\n\n\t      if (clear_flg) {\n\n\t        maxcode = MAXCODE(n_bits = g_init_bits);\n\t        clear_flg = false;\n\n\t      } else {\n\n\t        ++n_bits;\n\t        if (n_bits == maxbits) maxcode = maxmaxcode;\n\t        else maxcode = MAXCODE(n_bits);\n\t      }\n\t    }\n\n\t    if (code == EOFCode) {\n\n\t      // At EOF, write the rest of the buffer.\n\t      while (cur_bits > 0) {\n\t        char_out((cur_accum & 0xff), outs);\n\t        cur_accum >>= 8;\n\t        cur_bits -= 8;\n\t      }\n\n\t      flush_char(outs);\n\t    }\n\t  };\n\n\t  LZWEncoder.apply(this, arguments);\n\t  return exports;\n\t};\n\n\t/*\n\t * NeuQuant Neural-Net Quantization Algorithm\n\t * ------------------------------------------\n\t *\n\t * Copyright (c) 1994 Anthony Dekker\n\t *\n\t * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n\t * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n\t * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n\t * the algorithm.\n\t *\n\t * Any party obtaining a copy of these files from the author, directly or\n\t * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n\t * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n\t * this software and documentation files (the \"Software\"), including without\n\t * limitation the rights to use, copy, modify, merge, publish, distribute,\n\t * sublicense, and/or sell copies of the Software, and to permit persons who\n\t * receive copies from any such party to do so, with the only requirement being\n\t * that this copyright notice remain intact.\n\t */\n\n\t/*\n\t * This class handles Neural-Net quantization algorithm\n\t * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n\t * @author Thibault Imbert (AS3 version - bytearray.org)\n\t * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n\t * @version 0.1 AS3 implementation\n\t */\n\n\tNeuQuant = function () {\n\n\t  var exports = {};\n\t  var netsize = 256; /* number of colours used */\n\n\t  /* four primes near 500 - assume no image has a length so large */\n\t  /* that it is divisible by all four primes */\n\n\t  var prime1 = 499;\n\t  var prime2 = 491;\n\t  var prime3 = 487;\n\t  var prime4 = 503;\n\t  var minpicturebytes = (3 * prime4); /* minimum size for input image */\n\n\t\t/*\n\t\t * Program Skeleton ---------------- [select samplefac in range 1..30] [read\n\t\t * image from input file] pic = (unsigned char*) malloc(3*width*height);\n\t\t * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\n\t\t * image header, using writecolourmap(f)] inxbuild(); write output image using\n\t\t * inxsearch(b,g,r)\n\t\t */\n\n\t\t/*\n\t\t * Network Definitions -------------------\n\t\t */\n\n\t  var maxnetpos = (netsize - 1);\n\t  var netbiasshift = 4; /* bias for colour values */\n\t  var ncycles = 100; /* no. of learning cycles */\n\n\t  /* defs for freq and bias */\n\t  var intbiasshift = 16; /* bias for fractions */\n\t  var intbias = (1 << intbiasshift);\n\t  var gammashift = 10; /* gamma = 1024 */\n\t  var gamma = (1 << gammashift);\n\t  var betashift = 10;\n\t  var beta = (intbias >> betashift); /* beta = 1/1024 */\n\t  var betagamma = (intbias << (gammashift - betashift));\n\n\t  /* defs for decreasing radius factor */\n\t  var initrad = (netsize >> 3); /* for 256 cols, radius starts */\n\t  var radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\n\t  var radiusbias = (1 << radiusbiasshift);\n\t  var initradius = (initrad * radiusbias); /* and decreases by a */\n\t  var radiusdec = 30; /* factor of 1/30 each cycle */\n\n\t  /* defs for decreasing alpha factor */\n\t  var alphabiasshift = 10; /* alpha starts at 1.0 */\n\t  var initalpha = (1 << alphabiasshift);\n\t  var alphadec; /* biased by 10 bits */\n\n\t  /* radbias and alpharadbias used for radpower calculation */\n\t  var radbiasshift = 8;\n\t  var radbias = (1 << radbiasshift);\n\t  var alpharadbshift = (alphabiasshift + radbiasshift);\n\t  var alpharadbias = (1 << alpharadbshift);\n\n\t\t/*\n\t\t * Types and Global Variables --------------------------\n\t\t */\n\n\t  var thepicture; /* the input image itself */\n\t  var lengthcount; /* lengthcount = H*W*3 */\n\t  var samplefac; /* sampling factor 1..30 */\n\n\t  // typedef int pixel[4]; /* BGRc */\n\t  var network; /* the network itself - [netsize][4] */\n\t  var netindex = [];\n\n\t  /* for network lookup - really 256 */\n\t  var bias = [];\n\n\t  /* bias and freq arrays for learning */\n\t  var freq = [];\n\t  var radpower = [];\n\n\t  var NeuQuant = exports.NeuQuant = function NeuQuant(thepic, len, sample) {\n\n\t    var i;\n\t    var p;\n\n\t    thepicture = thepic;\n\t    lengthcount = len;\n\t    samplefac = sample;\n\n\t    network = new Array(netsize);\n\n\t    for (i = 0; i < netsize; i++) {\n\n\t      network[i] = new Array(4);\n\t      p = network[i];\n\t      p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\n\t      freq[i] = intbias / netsize; /* 1/netsize */\n\t      bias[i] = 0;\n\t    }\n\t  };\n\n\t  var colorMap = function colorMap() {\n\n\t    var map = [];\n\t    var index = new Array(netsize);\n\n\t    for (var i = 0; i < netsize; i++)\n\t      index[network[i][3]] = i;\n\n\t    var k = 0;\n\t    for (var l = 0; l < netsize; l++) {\n\t      var j = index[l];\n\t      map[k++] = (network[j][0]);\n\t      map[k++] = (network[j][1]);\n\t      map[k++] = (network[j][2]);\n\t    }\n\n\t    return map;\n\t  };\n\n\t\t/*\n\t\t * Insertion sort of network and building of netindex[0..255] (to do after\n\t\t * unbias)\n\t\t * -------------------------------------------------------------------------------\n\t\t */\n\n\t  var inxbuild = function inxbuild() {\n\n\t    var i;\n\t    var j;\n\t    var smallpos;\n\t    var smallval;\n\t    var p;\n\t    var q;\n\t    var previouscol;\n\t    var startpos;\n\n\t    previouscol = 0;\n\t    startpos = 0;\n\t    for (i = 0; i < netsize; i++) {\n\n\t      p = network[i];\n\t      smallpos = i;\n\t      smallval = p[1]; /* index on g */\n\n\t      /* find smallest in i..netsize-1 */\n\t      for (j = i + 1; j < netsize; j++) {\n\n\t        q = network[j];\n\t        if (q[1] < smallval) { /* index on g */\n\t          smallpos = j;\n\t          smallval = q[1]; /* index on g */\n\t        }\n\t      }\n\t      q = network[smallpos];\n\n\t      /* swap p (i) and q (smallpos) entries */\n\t      if (i != smallpos) {\n\t        j = q[0];\n\t        q[0] = p[0];\n\t        p[0] = j;\n\t        j = q[1];\n\t        q[1] = p[1];\n\t        p[1] = j;\n\t        j = q[2];\n\t        q[2] = p[2];\n\t        p[2] = j;\n\t        j = q[3];\n\t        q[3] = p[3];\n\t        p[3] = j;\n\t      }\n\n\t      /* smallval entry is now in position i */\n\n\t      if (smallval != previouscol) {\n\n\t        netindex[previouscol] = (startpos + i) >> 1;\n\n\t        for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\n\t        previouscol = smallval;\n\t        startpos = i;\n\t      }\n\t    }\n\n\t    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n\t    for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; /* really 256 */\n\t  };\n\n\t\t/*\n\t\t * Main Learning Loop ------------------\n\t\t */\n\n\t  var learn = function learn() {\n\n\t    var i;\n\t    var j;\n\t    var b;\n\t    var g;\n\t    var r;\n\t    var radius;\n\t    var rad;\n\t    var alpha;\n\t    var step;\n\t    var delta;\n\t    var samplepixels;\n\t    var p;\n\t    var pix;\n\t    var lim;\n\n\t    if (lengthcount < minpicturebytes) samplefac = 1;\n\n\t    alphadec = 30 + ((samplefac - 1) / 3);\n\t    p = thepicture;\n\t    pix = 0;\n\t    lim = lengthcount;\n\t    samplepixels = lengthcount / (3 * samplefac);\n\t    delta = (samplepixels / ncycles) | 0;\n\t    alpha = initalpha;\n\t    radius = initradius;\n\n\t    rad = radius >> radiusbiasshift;\n\t    if (rad <= 1) rad = 0;\n\n\t    for (i = 0; i < rad; i++) radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n\n\t    if (lengthcount < minpicturebytes) step = 3;\n\n\t    else if ((lengthcount % prime1) !== 0) step = 3 * prime1;\n\n\t    else {\n\n\t      if ((lengthcount % prime2) !== 0) step = 3 * prime2;\n\t      else {\n\t        if ((lengthcount % prime3) !== 0) step = 3 * prime3;\n\t        else step = 3 * prime4;\n\t      }\n\t    }\n\n\t    i = 0;\n\t    while (i < samplepixels) {\n\n\t      b = (p[pix + 0] & 0xff) << netbiasshift;\n\t      g = (p[pix + 1] & 0xff) << netbiasshift;\n\t      r = (p[pix + 2] & 0xff) << netbiasshift;\n\t      j = contest(b, g, r);\n\n\t      altersingle(alpha, j, b, g, r);\n\t      if (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\n\n\t      pix += step;\n\t      if (pix >= lim) pix -= lengthcount;\n\n\t      i++;\n\n\t      if (delta === 0) delta = 1;\n\n\t      if (i % delta === 0) {\n\t        alpha -= alpha / alphadec;\n\t        radius -= radius / radiusdec;\n\t        rad = radius >> radiusbiasshift;\n\n\t        if (rad <= 1) rad = 0;\n\n\t        for (j = 0; j < rad; j++) radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n\t      }\n\t    }\n\t  };\n\n\t\t/*\n\t\t ** Search for BGR values 0..255 (after net is unbiased) and return colour\n\t\t * index\n\t\t * ----------------------------------------------------------------------------\n\t\t */\n\n\t  var map = exports.map = function map(b, g, r) {\n\n\t    var i;\n\t    var j;\n\t    var dist;\n\t    var a;\n\t    var bestd;\n\t    var p;\n\t    var best;\n\n\t    bestd = 1000; /* biggest possible dist is 256*3 */\n\t    best = -1;\n\t    i = netindex[g]; /* index on g */\n\t    j = i - 1; /* start at netindex[g] and work outwards */\n\n\t    while ((i < netsize) || (j >= 0)) {\n\n\t      if (i < netsize) {\n\t        p = network[i];\n\t        dist = p[1] - g; /* inx key */\n\n\t        if (dist >= bestd) i = netsize; /* stop iter */\n\n\t        else {\n\n\t          i++;\n\t          if (dist < 0) dist = -dist;\n\t          a = p[0] - b;\n\t          if (a < 0) a = -a;\n\t          dist += a;\n\n\t          if (dist < bestd) {\n\t            a = p[2] - r;\n\t            if (a < 0) a = -a;\n\t            dist += a;\n\n\t            if (dist < bestd) {\n\t              bestd = dist;\n\t              best = p[3];\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      if (j >= 0) {\n\n\t        p = network[j];\n\t        dist = g - p[1]; /* inx key - reverse dif */\n\n\t        if (dist >= bestd) j = -1; /* stop iter */\n\n\t        else {\n\n\t          j--;\n\t          if (dist < 0) dist = -dist;\n\t          a = p[0] - b;\n\t          if (a < 0) a = -a;\n\t          dist += a;\n\n\t          if (dist < bestd) {\n\t            a = p[2] - r;\n\t            if (a < 0) a = -a;\n\t            dist += a;\n\t            if (dist < bestd) {\n\t              bestd = dist;\n\t              best = p[3];\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    return (best);\n\t  };\n\n\t  var process = exports.process = function process() {\n\t    learn();\n\t    unbiasnet();\n\t    inxbuild();\n\t    return colorMap();\n\t  };\n\n\t\t/*\n\t\t * Unbias network to give byte values 0..255 and record position i to prepare\n\t\t * for sort\n\t\t * -----------------------------------------------------------------------------------\n\t\t */\n\n\t  var unbiasnet = function unbiasnet() {\n\n\t    var i;\n\t    var j;\n\n\t    for (i = 0; i < netsize; i++) {\n\t      network[i][0] >>= netbiasshift;\n\t      network[i][1] >>= netbiasshift;\n\t      network[i][2] >>= netbiasshift;\n\t      network[i][3] = i; /* record colour no */\n\t    }\n\t  };\n\n\t\t/*\n\t\t * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\n\t\t * radpower[|i-j|]\n\t\t * ---------------------------------------------------------------------------------\n\t\t */\n\n\t  var alterneigh = function alterneigh(rad, i, b, g, r) {\n\n\t    var j;\n\t    var k;\n\t    var lo;\n\t    var hi;\n\t    var a;\n\t    var m;\n\t    var p;\n\n\t    lo = i - rad;\n\t    if (lo < -1) lo = -1;\n\n\t    hi = i + rad;\n\t    if (hi > netsize) hi = netsize;\n\n\t    j = i + 1;\n\t    k = i - 1;\n\t    m = 1;\n\n\t    while ((j < hi) || (k > lo)) {\n\t      a = radpower[m++];\n\n\t      if (j < hi) {\n\t        p = network[j++];\n\n\t        try {\n\t          p[0] -= (a * (p[0] - b)) / alpharadbias;\n\t          p[1] -= (a * (p[1] - g)) / alpharadbias;\n\t          p[2] -= (a * (p[2] - r)) / alpharadbias;\n\t        } catch (e) { } // prevents 1.3 miscompilation\n\t      }\n\n\t      if (k > lo) {\n\t        p = network[k--];\n\n\t        try {\n\t          p[0] -= (a * (p[0] - b)) / alpharadbias;\n\t          p[1] -= (a * (p[1] - g)) / alpharadbias;\n\t          p[2] -= (a * (p[2] - r)) / alpharadbias;\n\t        } catch (e) { }\n\t      }\n\t    }\n\t  };\n\n\t\t/*\n\t\t * Move neuron i towards biased (b,g,r) by factor alpha\n\t\t * ----------------------------------------------------\n\t\t */\n\n\t  var altersingle = function altersingle(alpha, i, b, g, r) {\n\n\t    /* alter hit neuron */\n\t    var n = network[i];\n\t    n[0] -= (alpha * (n[0] - b)) / initalpha;\n\t    n[1] -= (alpha * (n[1] - g)) / initalpha;\n\t    n[2] -= (alpha * (n[2] - r)) / initalpha;\n\t  };\n\n\t\t/*\n\t\t * Search for biased BGR values ----------------------------\n\t\t */\n\n\t  var contest = function contest(b, g, r) {\n\n\t    /* finds closest neuron (min dist) and updates freq */\n\t    /* finds best neuron (min dist-bias) and returns position */\n\t    /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\n\t    /* bias[i] = gamma*((1/netsize)-freq[i]) */\n\n\t    var i;\n\t    var dist;\n\t    var a;\n\t    var biasdist;\n\t    var betafreq;\n\t    var bestpos;\n\t    var bestbiaspos;\n\t    var bestd;\n\t    var bestbiasd;\n\t    var n;\n\n\t    bestd = ~(1 << 31);\n\t    bestbiasd = bestd;\n\t    bestpos = -1;\n\t    bestbiaspos = bestpos;\n\n\t    for (i = 0; i < netsize; i++) {\n\t      n = network[i];\n\t      dist = n[0] - b;\n\t      if (dist < 0) dist = -dist;\n\t      a = n[1] - g;\n\t      if (a < 0) a = -a;\n\t      dist += a;\n\t      a = n[2] - r;\n\t      if (a < 0) a = -a;\n\t      dist += a;\n\n\t      if (dist < bestd) {\n\t        bestd = dist;\n\t        bestpos = i;\n\t      }\n\n\t      biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n\n\t      if (biasdist < bestbiasd) {\n\t        bestbiasd = biasdist;\n\t        bestbiaspos = i;\n\t      }\n\n\t      betafreq = (freq[i] >> betashift);\n\t      freq[i] -= betafreq;\n\t      bias[i] += (betafreq << gammashift);\n\t    }\n\n\t    freq[bestpos] += beta;\n\t    bias[bestpos] -= betagamma;\n\t    return (bestbiaspos);\n\t  };\n\n\t  NeuQuant.apply(this, arguments);\n\t  return exports;\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./web_modules/gcc/index.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}